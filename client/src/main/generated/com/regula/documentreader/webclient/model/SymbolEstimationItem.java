/*
 * Regula Document Reader Web API
 * Documents recognition as easy as reading two bytes.   # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core
 *
 * The version of the OpenAPI document: 7.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.regula.documentreader.webclient.model;

import com.google.gson.Gson;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.regula.documentreader.webclient.JSON;
import java.io.IOException;
import java.util.HashSet;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/** SymbolEstimationItem */
@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen",
    comments = "Generator version: 7.12.0")
public class SymbolEstimationItem {
  public static final String SERIALIZED_NAME_A_L_I_G_N_M_E_N_T_N_E_A_R_E_S_T_S_Y_M_B_O_L_S =
      "ALIGNMENT_NEAREST_SYMBOLS";

  @SerializedName(SERIALIZED_NAME_A_L_I_G_N_M_E_N_T_N_E_A_R_E_S_T_S_Y_M_B_O_L_S)
  @javax.annotation.Nonnull
  private Integer ALIGNMENT_NEAREST_SYMBOLS;

  public static final String SERIALIZED_NAME_C_O_N_T_R_A_S_T_P_R_I_N_T = "CONTRAST_PRINT";

  @SerializedName(SERIALIZED_NAME_C_O_N_T_R_A_S_T_P_R_I_N_T)
  @javax.annotation.Nonnull
  private Integer CONTRAST_PRINT;

  public static final String SERIALIZED_NAME_C_O_N_T_R_A_S_T_S_Y_M_B_O_L = "CONTRAST_SYMBOL";

  @SerializedName(SERIALIZED_NAME_C_O_N_T_R_A_S_T_S_Y_M_B_O_L)
  @javax.annotation.Nonnull
  private Integer CONTRAST_SYMBOL;

  public static final String SERIALIZED_NAME_CHAR_SYMBOL = "CharSymbol";

  @SerializedName(SERIALIZED_NAME_CHAR_SYMBOL)
  @javax.annotation.Nonnull
  private Integer charSymbol;

  public static final String SERIALIZED_NAME_E_D_G_E = "EDGE";

  @SerializedName(SERIALIZED_NAME_E_D_G_E)
  @javax.annotation.Nonnull
  private Integer EDGE;

  public static final String SERIALIZED_NAME_E_M_P_T_I_N_E_S_S = "EMPTINESS";

  @SerializedName(SERIALIZED_NAME_E_M_P_T_I_N_E_S_S)
  @javax.annotation.Nonnull
  private Integer EMPTINESS;

  public static final String SERIALIZED_NAME_S_T_A_I_N = "STAIN";

  @SerializedName(SERIALIZED_NAME_S_T_A_I_N)
  @javax.annotation.Nonnull
  private Integer STAIN;

  public static final String SERIALIZED_NAME_S_Y_M_B_O_L_S_I_N_T_E_R_V_A_L = "SYMBOLS_INTERVAL";

  @SerializedName(SERIALIZED_NAME_S_Y_M_B_O_L_S_I_N_T_E_R_V_A_L)
  @javax.annotation.Nonnull
  private Integer SYMBOLS_INTERVAL;

  public static final String SERIALIZED_NAME_S_Y_M_B_O_L_P_A_R_A_M = "SYMBOL_PARAM";

  @SerializedName(SERIALIZED_NAME_S_Y_M_B_O_L_P_A_R_A_M)
  @javax.annotation.Nonnull
  private Integer SYMBOL_PARAM;

  public static final String SERIALIZED_NAME_S_Y_M_B_O_L_S_I_Z_E = "SYMBOL_SIZE";

  @SerializedName(SERIALIZED_NAME_S_Y_M_B_O_L_S_I_Z_E)
  @javax.annotation.Nonnull
  private Integer SYMBOL_SIZE;

  public static final String SERIALIZED_NAME_SIZE_ERROR_ALIGN_WITH_NEXT = "SizeErrorAlignWithNext";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_ALIGN_WITH_NEXT)
  @javax.annotation.Nonnull
  private Integer sizeErrorAlignWithNext;

  public static final String SERIALIZED_NAME_SIZE_ERROR_ALIGN_WITH_PREV = "SizeErrorAlignWithPrev";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_ALIGN_WITH_PREV)
  @javax.annotation.Nonnull
  private Integer sizeErrorAlignWithPrev;

  public static final String SERIALIZED_NAME_SIZE_ERROR_INTERV_WITH_NEXT =
      "SizeErrorIntervWithNext";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_INTERV_WITH_NEXT)
  @javax.annotation.Nonnull
  private Integer sizeErrorIntervWithNext;

  public static final String SERIALIZED_NAME_SIZE_ERROR_INTERV_WITH_PREV =
      "SizeErrorIntervWithPrev";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_INTERV_WITH_PREV)
  @javax.annotation.Nonnull
  private Integer sizeErrorIntervWithPrev;

  public static final String SERIALIZED_NAME_SIZE_ERROR_SYMBOL_HEIGHT = "SizeErrorSymbolHeight";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_SYMBOL_HEIGHT)
  @javax.annotation.Nonnull
  private Integer sizeErrorSymbolHeight;

  public static final String SERIALIZED_NAME_SIZE_ERROR_SYMBOL_WIDTH = "SizeErrorSymbolWidth";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_SYMBOL_WIDTH)
  @javax.annotation.Nonnull
  private Integer sizeErrorSymbolWidth;

  public static final String SERIALIZED_NAME_SYMBOL_BOUNDS = "SymbolBounds";

  @SerializedName(SERIALIZED_NAME_SYMBOL_BOUNDS)
  @javax.annotation.Nonnull
  private RectangleCoordinates symbolBounds;

  public SymbolEstimationItem() {}

  public SymbolEstimationItem ALIGNMENT_NEAREST_SYMBOLS(
      @javax.annotation.Nonnull Integer ALIGNMENT_NEAREST_SYMBOLS) {
    this.ALIGNMENT_NEAREST_SYMBOLS = ALIGNMENT_NEAREST_SYMBOLS;
    return this;
  }

  /**
   * Get ALIGNMENT_NEAREST_SYMBOLS
   *
   * @return ALIGNMENT_NEAREST_SYMBOLS
   */
  @javax.annotation.Nonnull
  public Integer getALIGNMENTNEARESTSYMBOLS() {
    return ALIGNMENT_NEAREST_SYMBOLS;
  }

  public void setALIGNMENTNEARESTSYMBOLS(
      @javax.annotation.Nonnull Integer ALIGNMENT_NEAREST_SYMBOLS) {
    this.ALIGNMENT_NEAREST_SYMBOLS = ALIGNMENT_NEAREST_SYMBOLS;
  }

  public SymbolEstimationItem CONTRAST_PRINT(@javax.annotation.Nonnull Integer CONTRAST_PRINT) {
    this.CONTRAST_PRINT = CONTRAST_PRINT;
    return this;
  }

  /**
   * Get CONTRAST_PRINT
   *
   * @return CONTRAST_PRINT
   */
  @javax.annotation.Nonnull
  public Integer getCONTRASTPRINT() {
    return CONTRAST_PRINT;
  }

  public void setCONTRASTPRINT(@javax.annotation.Nonnull Integer CONTRAST_PRINT) {
    this.CONTRAST_PRINT = CONTRAST_PRINT;
  }

  public SymbolEstimationItem CONTRAST_SYMBOL(@javax.annotation.Nonnull Integer CONTRAST_SYMBOL) {
    this.CONTRAST_SYMBOL = CONTRAST_SYMBOL;
    return this;
  }

  /**
   * Get CONTRAST_SYMBOL
   *
   * @return CONTRAST_SYMBOL
   */
  @javax.annotation.Nonnull
  public Integer getCONTRASTSYMBOL() {
    return CONTRAST_SYMBOL;
  }

  public void setCONTRASTSYMBOL(@javax.annotation.Nonnull Integer CONTRAST_SYMBOL) {
    this.CONTRAST_SYMBOL = CONTRAST_SYMBOL;
  }

  public SymbolEstimationItem charSymbol(@javax.annotation.Nonnull Integer charSymbol) {
    this.charSymbol = charSymbol;
    return this;
  }

  /**
   * Get charSymbol
   *
   * @return charSymbol
   */
  @javax.annotation.Nonnull
  public Integer getCharSymbol() {
    return charSymbol;
  }

  public void setCharSymbol(@javax.annotation.Nonnull Integer charSymbol) {
    this.charSymbol = charSymbol;
  }

  public SymbolEstimationItem EDGE(@javax.annotation.Nonnull Integer EDGE) {
    this.EDGE = EDGE;
    return this;
  }

  /**
   * Get EDGE
   *
   * @return EDGE
   */
  @javax.annotation.Nonnull
  public Integer getEDGE() {
    return EDGE;
  }

  public void setEDGE(@javax.annotation.Nonnull Integer EDGE) {
    this.EDGE = EDGE;
  }

  public SymbolEstimationItem EMPTINESS(@javax.annotation.Nonnull Integer EMPTINESS) {
    this.EMPTINESS = EMPTINESS;
    return this;
  }

  /**
   * Get EMPTINESS
   *
   * @return EMPTINESS
   */
  @javax.annotation.Nonnull
  public Integer getEMPTINESS() {
    return EMPTINESS;
  }

  public void setEMPTINESS(@javax.annotation.Nonnull Integer EMPTINESS) {
    this.EMPTINESS = EMPTINESS;
  }

  public SymbolEstimationItem STAIN(@javax.annotation.Nonnull Integer STAIN) {
    this.STAIN = STAIN;
    return this;
  }

  /**
   * Get STAIN
   *
   * @return STAIN
   */
  @javax.annotation.Nonnull
  public Integer getSTAIN() {
    return STAIN;
  }

  public void setSTAIN(@javax.annotation.Nonnull Integer STAIN) {
    this.STAIN = STAIN;
  }

  public SymbolEstimationItem SYMBOLS_INTERVAL(@javax.annotation.Nonnull Integer SYMBOLS_INTERVAL) {
    this.SYMBOLS_INTERVAL = SYMBOLS_INTERVAL;
    return this;
  }

  /**
   * Get SYMBOLS_INTERVAL
   *
   * @return SYMBOLS_INTERVAL
   */
  @javax.annotation.Nonnull
  public Integer getSYMBOLSINTERVAL() {
    return SYMBOLS_INTERVAL;
  }

  public void setSYMBOLSINTERVAL(@javax.annotation.Nonnull Integer SYMBOLS_INTERVAL) {
    this.SYMBOLS_INTERVAL = SYMBOLS_INTERVAL;
  }

  public SymbolEstimationItem SYMBOL_PARAM(@javax.annotation.Nonnull Integer SYMBOL_PARAM) {
    this.SYMBOL_PARAM = SYMBOL_PARAM;
    return this;
  }

  /**
   * Get SYMBOL_PARAM
   *
   * @return SYMBOL_PARAM
   */
  @javax.annotation.Nonnull
  public Integer getSYMBOLPARAM() {
    return SYMBOL_PARAM;
  }

  public void setSYMBOLPARAM(@javax.annotation.Nonnull Integer SYMBOL_PARAM) {
    this.SYMBOL_PARAM = SYMBOL_PARAM;
  }

  public SymbolEstimationItem SYMBOL_SIZE(@javax.annotation.Nonnull Integer SYMBOL_SIZE) {
    this.SYMBOL_SIZE = SYMBOL_SIZE;
    return this;
  }

  /**
   * Get SYMBOL_SIZE
   *
   * @return SYMBOL_SIZE
   */
  @javax.annotation.Nonnull
  public Integer getSYMBOLSIZE() {
    return SYMBOL_SIZE;
  }

  public void setSYMBOLSIZE(@javax.annotation.Nonnull Integer SYMBOL_SIZE) {
    this.SYMBOL_SIZE = SYMBOL_SIZE;
  }

  public SymbolEstimationItem sizeErrorAlignWithNext(
      @javax.annotation.Nonnull Integer sizeErrorAlignWithNext) {
    this.sizeErrorAlignWithNext = sizeErrorAlignWithNext;
    return this;
  }

  /**
   * Get sizeErrorAlignWithNext
   *
   * @return sizeErrorAlignWithNext
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorAlignWithNext() {
    return sizeErrorAlignWithNext;
  }

  public void setSizeErrorAlignWithNext(@javax.annotation.Nonnull Integer sizeErrorAlignWithNext) {
    this.sizeErrorAlignWithNext = sizeErrorAlignWithNext;
  }

  public SymbolEstimationItem sizeErrorAlignWithPrev(
      @javax.annotation.Nonnull Integer sizeErrorAlignWithPrev) {
    this.sizeErrorAlignWithPrev = sizeErrorAlignWithPrev;
    return this;
  }

  /**
   * Get sizeErrorAlignWithPrev
   *
   * @return sizeErrorAlignWithPrev
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorAlignWithPrev() {
    return sizeErrorAlignWithPrev;
  }

  public void setSizeErrorAlignWithPrev(@javax.annotation.Nonnull Integer sizeErrorAlignWithPrev) {
    this.sizeErrorAlignWithPrev = sizeErrorAlignWithPrev;
  }

  public SymbolEstimationItem sizeErrorIntervWithNext(
      @javax.annotation.Nonnull Integer sizeErrorIntervWithNext) {
    this.sizeErrorIntervWithNext = sizeErrorIntervWithNext;
    return this;
  }

  /**
   * Get sizeErrorIntervWithNext
   *
   * @return sizeErrorIntervWithNext
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorIntervWithNext() {
    return sizeErrorIntervWithNext;
  }

  public void setSizeErrorIntervWithNext(
      @javax.annotation.Nonnull Integer sizeErrorIntervWithNext) {
    this.sizeErrorIntervWithNext = sizeErrorIntervWithNext;
  }

  public SymbolEstimationItem sizeErrorIntervWithPrev(
      @javax.annotation.Nonnull Integer sizeErrorIntervWithPrev) {
    this.sizeErrorIntervWithPrev = sizeErrorIntervWithPrev;
    return this;
  }

  /**
   * Get sizeErrorIntervWithPrev
   *
   * @return sizeErrorIntervWithPrev
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorIntervWithPrev() {
    return sizeErrorIntervWithPrev;
  }

  public void setSizeErrorIntervWithPrev(
      @javax.annotation.Nonnull Integer sizeErrorIntervWithPrev) {
    this.sizeErrorIntervWithPrev = sizeErrorIntervWithPrev;
  }

  public SymbolEstimationItem sizeErrorSymbolHeight(
      @javax.annotation.Nonnull Integer sizeErrorSymbolHeight) {
    this.sizeErrorSymbolHeight = sizeErrorSymbolHeight;
    return this;
  }

  /**
   * Get sizeErrorSymbolHeight
   *
   * @return sizeErrorSymbolHeight
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorSymbolHeight() {
    return sizeErrorSymbolHeight;
  }

  public void setSizeErrorSymbolHeight(@javax.annotation.Nonnull Integer sizeErrorSymbolHeight) {
    this.sizeErrorSymbolHeight = sizeErrorSymbolHeight;
  }

  public SymbolEstimationItem sizeErrorSymbolWidth(
      @javax.annotation.Nonnull Integer sizeErrorSymbolWidth) {
    this.sizeErrorSymbolWidth = sizeErrorSymbolWidth;
    return this;
  }

  /**
   * Get sizeErrorSymbolWidth
   *
   * @return sizeErrorSymbolWidth
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorSymbolWidth() {
    return sizeErrorSymbolWidth;
  }

  public void setSizeErrorSymbolWidth(@javax.annotation.Nonnull Integer sizeErrorSymbolWidth) {
    this.sizeErrorSymbolWidth = sizeErrorSymbolWidth;
  }

  public SymbolEstimationItem symbolBounds(
      @javax.annotation.Nonnull RectangleCoordinates symbolBounds) {
    this.symbolBounds = symbolBounds;
    return this;
  }

  /**
   * Get symbolBounds
   *
   * @return symbolBounds
   */
  @javax.annotation.Nonnull
  public RectangleCoordinates getSymbolBounds() {
    return symbolBounds;
  }

  public void setSymbolBounds(@javax.annotation.Nonnull RectangleCoordinates symbolBounds) {
    this.symbolBounds = symbolBounds;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    SymbolEstimationItem symbolEstimationItem = (SymbolEstimationItem) o;
    return Objects.equals(
            this.ALIGNMENT_NEAREST_SYMBOLS, symbolEstimationItem.ALIGNMENT_NEAREST_SYMBOLS)
        && Objects.equals(this.CONTRAST_PRINT, symbolEstimationItem.CONTRAST_PRINT)
        && Objects.equals(this.CONTRAST_SYMBOL, symbolEstimationItem.CONTRAST_SYMBOL)
        && Objects.equals(this.charSymbol, symbolEstimationItem.charSymbol)
        && Objects.equals(this.EDGE, symbolEstimationItem.EDGE)
        && Objects.equals(this.EMPTINESS, symbolEstimationItem.EMPTINESS)
        && Objects.equals(this.STAIN, symbolEstimationItem.STAIN)
        && Objects.equals(this.SYMBOLS_INTERVAL, symbolEstimationItem.SYMBOLS_INTERVAL)
        && Objects.equals(this.SYMBOL_PARAM, symbolEstimationItem.SYMBOL_PARAM)
        && Objects.equals(this.SYMBOL_SIZE, symbolEstimationItem.SYMBOL_SIZE)
        && Objects.equals(this.sizeErrorAlignWithNext, symbolEstimationItem.sizeErrorAlignWithNext)
        && Objects.equals(this.sizeErrorAlignWithPrev, symbolEstimationItem.sizeErrorAlignWithPrev)
        && Objects.equals(
            this.sizeErrorIntervWithNext, symbolEstimationItem.sizeErrorIntervWithNext)
        && Objects.equals(
            this.sizeErrorIntervWithPrev, symbolEstimationItem.sizeErrorIntervWithPrev)
        && Objects.equals(this.sizeErrorSymbolHeight, symbolEstimationItem.sizeErrorSymbolHeight)
        && Objects.equals(this.sizeErrorSymbolWidth, symbolEstimationItem.sizeErrorSymbolWidth)
        && Objects.equals(this.symbolBounds, symbolEstimationItem.symbolBounds);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        ALIGNMENT_NEAREST_SYMBOLS,
        CONTRAST_PRINT,
        CONTRAST_SYMBOL,
        charSymbol,
        EDGE,
        EMPTINESS,
        STAIN,
        SYMBOLS_INTERVAL,
        SYMBOL_PARAM,
        SYMBOL_SIZE,
        sizeErrorAlignWithNext,
        sizeErrorAlignWithPrev,
        sizeErrorIntervWithNext,
        sizeErrorIntervWithPrev,
        sizeErrorSymbolHeight,
        sizeErrorSymbolWidth,
        symbolBounds);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class SymbolEstimationItem {\n");
    sb.append("    ALIGNMENT_NEAREST_SYMBOLS: ")
        .append(toIndentedString(ALIGNMENT_NEAREST_SYMBOLS))
        .append("\n");
    sb.append("    CONTRAST_PRINT: ").append(toIndentedString(CONTRAST_PRINT)).append("\n");
    sb.append("    CONTRAST_SYMBOL: ").append(toIndentedString(CONTRAST_SYMBOL)).append("\n");
    sb.append("    charSymbol: ").append(toIndentedString(charSymbol)).append("\n");
    sb.append("    EDGE: ").append(toIndentedString(EDGE)).append("\n");
    sb.append("    EMPTINESS: ").append(toIndentedString(EMPTINESS)).append("\n");
    sb.append("    STAIN: ").append(toIndentedString(STAIN)).append("\n");
    sb.append("    SYMBOLS_INTERVAL: ").append(toIndentedString(SYMBOLS_INTERVAL)).append("\n");
    sb.append("    SYMBOL_PARAM: ").append(toIndentedString(SYMBOL_PARAM)).append("\n");
    sb.append("    SYMBOL_SIZE: ").append(toIndentedString(SYMBOL_SIZE)).append("\n");
    sb.append("    sizeErrorAlignWithNext: ")
        .append(toIndentedString(sizeErrorAlignWithNext))
        .append("\n");
    sb.append("    sizeErrorAlignWithPrev: ")
        .append(toIndentedString(sizeErrorAlignWithPrev))
        .append("\n");
    sb.append("    sizeErrorIntervWithNext: ")
        .append(toIndentedString(sizeErrorIntervWithNext))
        .append("\n");
    sb.append("    sizeErrorIntervWithPrev: ")
        .append(toIndentedString(sizeErrorIntervWithPrev))
        .append("\n");
    sb.append("    sizeErrorSymbolHeight: ")
        .append(toIndentedString(sizeErrorSymbolHeight))
        .append("\n");
    sb.append("    sizeErrorSymbolWidth: ")
        .append(toIndentedString(sizeErrorSymbolWidth))
        .append("\n");
    sb.append("    symbolBounds: ").append(toIndentedString(symbolBounds)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ALIGNMENT_NEAREST_SYMBOLS");
    openapiFields.add("CONTRAST_PRINT");
    openapiFields.add("CONTRAST_SYMBOL");
    openapiFields.add("CharSymbol");
    openapiFields.add("EDGE");
    openapiFields.add("EMPTINESS");
    openapiFields.add("STAIN");
    openapiFields.add("SYMBOLS_INTERVAL");
    openapiFields.add("SYMBOL_PARAM");
    openapiFields.add("SYMBOL_SIZE");
    openapiFields.add("SizeErrorAlignWithNext");
    openapiFields.add("SizeErrorAlignWithPrev");
    openapiFields.add("SizeErrorIntervWithNext");
    openapiFields.add("SizeErrorIntervWithPrev");
    openapiFields.add("SizeErrorSymbolHeight");
    openapiFields.add("SizeErrorSymbolWidth");
    openapiFields.add("SymbolBounds");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ALIGNMENT_NEAREST_SYMBOLS");
    openapiRequiredFields.add("CONTRAST_PRINT");
    openapiRequiredFields.add("CONTRAST_SYMBOL");
    openapiRequiredFields.add("CharSymbol");
    openapiRequiredFields.add("EDGE");
    openapiRequiredFields.add("EMPTINESS");
    openapiRequiredFields.add("STAIN");
    openapiRequiredFields.add("SYMBOLS_INTERVAL");
    openapiRequiredFields.add("SYMBOL_PARAM");
    openapiRequiredFields.add("SYMBOL_SIZE");
    openapiRequiredFields.add("SizeErrorAlignWithNext");
    openapiRequiredFields.add("SizeErrorAlignWithPrev");
    openapiRequiredFields.add("SizeErrorIntervWithNext");
    openapiRequiredFields.add("SizeErrorIntervWithPrev");
    openapiRequiredFields.add("SizeErrorSymbolHeight");
    openapiRequiredFields.add("SizeErrorSymbolWidth");
    openapiRequiredFields.add("SymbolBounds");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to SymbolEstimationItem
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
    if (jsonElement == null) {
      if (!SymbolEstimationItem.openapiRequiredFields
          .isEmpty()) { // has required fields but JSON element is null
        throw new IllegalArgumentException(
            String.format(
                "The required field(s) %s in SymbolEstimationItem is not found in the empty JSON string",
                SymbolEstimationItem.openapiRequiredFields.toString()));
      }
    }

    Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
    // check to see if the JSON string contains additional fields
    for (Map.Entry<String, JsonElement> entry : entries) {
      if (!SymbolEstimationItem.openapiFields.contains(entry.getKey())) {
        throw new IllegalArgumentException(
            String.format(
                "The field `%s` in the JSON string is not defined in the `SymbolEstimationItem` properties. JSON: %s",
                entry.getKey(), jsonElement.toString()));
      }
    }

    // check to make sure all required properties/fields are present in the JSON string
    for (String requiredField : SymbolEstimationItem.openapiRequiredFields) {
      if (jsonElement.getAsJsonObject().get(requiredField) == null) {
        throw new IllegalArgumentException(
            String.format(
                "The required field `%s` is not found in the JSON string: %s",
                requiredField, jsonElement.toString()));
      }
    }
    JsonObject jsonObj = jsonElement.getAsJsonObject();
    // validate the required field `SymbolBounds`
    RectangleCoordinates.validateJsonElement(jsonObj.get("SymbolBounds"));
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
      if (!SymbolEstimationItem.class.isAssignableFrom(type.getRawType())) {
        return null; // this class only serializes 'SymbolEstimationItem' and its subtypes
      }
      final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
      final TypeAdapter<SymbolEstimationItem> thisAdapter =
          gson.getDelegateAdapter(this, TypeToken.get(SymbolEstimationItem.class));

      return (TypeAdapter<T>)
          new TypeAdapter<SymbolEstimationItem>() {
            @Override
            public void write(JsonWriter out, SymbolEstimationItem value) throws IOException {
              JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
              elementAdapter.write(out, obj);
            }

            @Override
            public SymbolEstimationItem read(JsonReader in) throws IOException {
              JsonElement jsonElement = elementAdapter.read(in);
              validateJsonElement(jsonElement);
              return thisAdapter.fromJsonTree(jsonElement);
            }
          }.nullSafe();
    }
  }

  /**
   * Create an instance of SymbolEstimationItem given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of SymbolEstimationItem
   * @throws IOException if the JSON string is invalid with respect to SymbolEstimationItem
   */
  public static SymbolEstimationItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, SymbolEstimationItem.class);
  }

  /**
   * Convert an instance of SymbolEstimationItem to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
