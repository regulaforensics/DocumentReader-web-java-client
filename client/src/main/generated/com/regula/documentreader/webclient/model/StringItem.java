/*
 * Regula Document Reader Web API
 * Documents recognition as easy as reading two bytes.   # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core
 *
 * The version of the OpenAPI document: 7.4.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.regula.documentreader.webclient.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.regula.documentreader.webclient.JSON;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/** StringItem */
@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen",
    comments = "Generator version: 7.12.0")
public class StringItem {
  public static final String SERIALIZED_NAME_A_L_I_G_N_M_E_N_T_S_Y_M_B_O_L_S_I_N_S_T_R_I_N_G =
      "ALIGNMENT_SYMBOLS_IN_STRING";

  @SerializedName(SERIALIZED_NAME_A_L_I_G_N_M_E_N_T_S_Y_M_B_O_L_S_I_N_S_T_R_I_N_G)
  @javax.annotation.Nonnull
  private Integer ALIGNMENT_SYMBOLS_IN_STRING;

  public static final String SERIALIZED_NAME_C_H_E_C_K_S_U_M_S = "CHECK_SUMS";

  @SerializedName(SERIALIZED_NAME_C_H_E_C_K_S_U_M_S)
  @javax.annotation.Nonnull
  private Integer CHECK_SUMS;

  public static final String SERIALIZED_NAME_ERROR_P_O_S_I_T_I_O_N = "ErrorPOSITION";

  @SerializedName(SERIALIZED_NAME_ERROR_P_O_S_I_T_I_O_N)
  @javax.annotation.Nonnull
  private ErrorCoordinates errorPOSITION;

  public static final String SERIALIZED_NAME_FIELD_COUNT = "FieldCount";

  @SerializedName(SERIALIZED_NAME_FIELD_COUNT)
  @javax.annotation.Nonnull
  private Integer fieldCount;

  public static final String SERIALIZED_NAME_FIELDS = "Fields";

  @SerializedName(SERIALIZED_NAME_FIELDS)
  @javax.annotation.Nonnull
  private List<FieldItem> fields;

  public static final String SERIALIZED_NAME_S_T_R_I_N_G_S_D_I_S_T_A_N_C_E = "STRINGS_DISTANCE";

  @SerializedName(SERIALIZED_NAME_S_T_R_I_N_G_S_D_I_S_T_A_N_C_E)
  @javax.annotation.Nonnull
  private Integer STRINGS_DISTANCE;

  public static final String SERIALIZED_NAME_S_T_R_I_N_G_S_I_N_T_E_R_V_A_L = "STRINGS_INTERVAL";

  @SerializedName(SERIALIZED_NAME_S_T_R_I_N_G_S_I_N_T_E_R_V_A_L)
  @javax.annotation.Nonnull
  private Integer STRINGS_INTERVAL;

  public static final String SERIALIZED_NAME_S_T_R_I_N_G_F_I_L_L_I_N_G = "STRING_FILLING";

  @SerializedName(SERIALIZED_NAME_S_T_R_I_N_G_F_I_L_L_I_N_G)
  @javax.annotation.Nonnull
  private Integer STRING_FILLING;

  public static final String SERIALIZED_NAME_S_T_R_I_N_G_P_O_S_I_T_I_O_N = "STRING_POSITION";

  @SerializedName(SERIALIZED_NAME_S_T_R_I_N_G_P_O_S_I_T_I_O_N)
  @javax.annotation.Nonnull
  private Integer STRING_POSITION;

  public static final String SERIALIZED_NAME_S_Y_M_B_O_L_S_P_A_R_A_M = "SYMBOLS_PARAM";

  @SerializedName(SERIALIZED_NAME_S_Y_M_B_O_L_S_P_A_R_A_M)
  @javax.annotation.Nonnull
  private Integer SYMBOLS_PARAM;

  public static final String SERIALIZED_NAME_SIZE_ERROR_A_L_I_G_N_M_E_N_T = "SizeError_ALIGNMENT";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_A_L_I_G_N_M_E_N_T)
  @javax.annotation.Nonnull
  private Integer sizeErrorALIGNMENT;

  public static final String SERIALIZED_NAME_SIZE_ERROR_D_I_S_T_A_N_C_E = "SizeError_DISTANCE";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_D_I_S_T_A_N_C_E)
  @javax.annotation.Nonnull
  private Integer sizeErrorDISTANCE;

  public static final String SERIALIZED_NAME_SIZE_ERROR_I_N_T_E_R_V_A_L = "SizeError_INTERVAL";

  @SerializedName(SERIALIZED_NAME_SIZE_ERROR_I_N_T_E_R_V_A_L)
  @javax.annotation.Nonnull
  private Integer sizeErrorINTERVAL;

  public static final String SERIALIZED_NAME_STRING_ANGLE = "StringAngle";

  @SerializedName(SERIALIZED_NAME_STRING_ANGLE)
  @javax.annotation.Nonnull
  private Integer stringAngle;

  public static final String SERIALIZED_NAME_STRING_BORDERS = "StringBorders";

  @SerializedName(SERIALIZED_NAME_STRING_BORDERS)
  @javax.annotation.Nonnull
  private RectangleCoordinates stringBorders;

  public static final String SERIALIZED_NAME_SYMBOLS_COUNT = "SymbolsCount";

  @SerializedName(SERIALIZED_NAME_SYMBOLS_COUNT)
  @javax.annotation.Nonnull
  private Integer symbolsCount;

  public static final String SERIALIZED_NAME_SYMBOLS_ESTIMATIONS = "SymbolsEstimations";

  @SerializedName(SERIALIZED_NAME_SYMBOLS_ESTIMATIONS)
  @javax.annotation.Nonnull
  private List<SymbolEstimationItem> symbolsEstimations;

  public StringItem() {}

  public StringItem ALIGNMENT_SYMBOLS_IN_STRING(
      @javax.annotation.Nonnull Integer ALIGNMENT_SYMBOLS_IN_STRING) {
    this.ALIGNMENT_SYMBOLS_IN_STRING = ALIGNMENT_SYMBOLS_IN_STRING;
    return this;
  }

  /**
   * Get ALIGNMENT_SYMBOLS_IN_STRING
   *
   * @return ALIGNMENT_SYMBOLS_IN_STRING
   */
  @javax.annotation.Nonnull
  public Integer getALIGNMENTSYMBOLSINSTRING() {
    return ALIGNMENT_SYMBOLS_IN_STRING;
  }

  public void setALIGNMENTSYMBOLSINSTRING(
      @javax.annotation.Nonnull Integer ALIGNMENT_SYMBOLS_IN_STRING) {
    this.ALIGNMENT_SYMBOLS_IN_STRING = ALIGNMENT_SYMBOLS_IN_STRING;
  }

  public StringItem CHECK_SUMS(@javax.annotation.Nonnull Integer CHECK_SUMS) {
    this.CHECK_SUMS = CHECK_SUMS;
    return this;
  }

  /**
   * Get CHECK_SUMS
   *
   * @return CHECK_SUMS
   */
  @javax.annotation.Nonnull
  public Integer getCHECKSUMS() {
    return CHECK_SUMS;
  }

  public void setCHECKSUMS(@javax.annotation.Nonnull Integer CHECK_SUMS) {
    this.CHECK_SUMS = CHECK_SUMS;
  }

  public StringItem errorPOSITION(@javax.annotation.Nonnull ErrorCoordinates errorPOSITION) {
    this.errorPOSITION = errorPOSITION;
    return this;
  }

  /**
   * Get errorPOSITION
   *
   * @return errorPOSITION
   */
  @javax.annotation.Nonnull
  public ErrorCoordinates getErrorPOSITION() {
    return errorPOSITION;
  }

  public void setErrorPOSITION(@javax.annotation.Nonnull ErrorCoordinates errorPOSITION) {
    this.errorPOSITION = errorPOSITION;
  }

  public StringItem fieldCount(@javax.annotation.Nonnull Integer fieldCount) {
    this.fieldCount = fieldCount;
    return this;
  }

  /**
   * Get fieldCount
   *
   * @return fieldCount
   */
  @javax.annotation.Nonnull
  public Integer getFieldCount() {
    return fieldCount;
  }

  public void setFieldCount(@javax.annotation.Nonnull Integer fieldCount) {
    this.fieldCount = fieldCount;
  }

  public StringItem fields(@javax.annotation.Nonnull List<FieldItem> fields) {
    this.fields = fields;
    return this;
  }

  public StringItem addFieldsItem(FieldItem fieldsItem) {
    if (this.fields == null) {
      this.fields = new ArrayList<>();
    }
    this.fields.add(fieldsItem);
    return this;
  }

  /**
   * Get fields
   *
   * @return fields
   */
  @javax.annotation.Nonnull
  public List<FieldItem> getFields() {
    return fields;
  }

  public void setFields(@javax.annotation.Nonnull List<FieldItem> fields) {
    this.fields = fields;
  }

  public StringItem STRINGS_DISTANCE(@javax.annotation.Nonnull Integer STRINGS_DISTANCE) {
    this.STRINGS_DISTANCE = STRINGS_DISTANCE;
    return this;
  }

  /**
   * Get STRINGS_DISTANCE
   *
   * @return STRINGS_DISTANCE
   */
  @javax.annotation.Nonnull
  public Integer getSTRINGSDISTANCE() {
    return STRINGS_DISTANCE;
  }

  public void setSTRINGSDISTANCE(@javax.annotation.Nonnull Integer STRINGS_DISTANCE) {
    this.STRINGS_DISTANCE = STRINGS_DISTANCE;
  }

  public StringItem STRINGS_INTERVAL(@javax.annotation.Nonnull Integer STRINGS_INTERVAL) {
    this.STRINGS_INTERVAL = STRINGS_INTERVAL;
    return this;
  }

  /**
   * Get STRINGS_INTERVAL
   *
   * @return STRINGS_INTERVAL
   */
  @javax.annotation.Nonnull
  public Integer getSTRINGSINTERVAL() {
    return STRINGS_INTERVAL;
  }

  public void setSTRINGSINTERVAL(@javax.annotation.Nonnull Integer STRINGS_INTERVAL) {
    this.STRINGS_INTERVAL = STRINGS_INTERVAL;
  }

  public StringItem STRING_FILLING(@javax.annotation.Nonnull Integer STRING_FILLING) {
    this.STRING_FILLING = STRING_FILLING;
    return this;
  }

  /**
   * Get STRING_FILLING
   *
   * @return STRING_FILLING
   */
  @javax.annotation.Nonnull
  public Integer getSTRINGFILLING() {
    return STRING_FILLING;
  }

  public void setSTRINGFILLING(@javax.annotation.Nonnull Integer STRING_FILLING) {
    this.STRING_FILLING = STRING_FILLING;
  }

  public StringItem STRING_POSITION(@javax.annotation.Nonnull Integer STRING_POSITION) {
    this.STRING_POSITION = STRING_POSITION;
    return this;
  }

  /**
   * Get STRING_POSITION
   *
   * @return STRING_POSITION
   */
  @javax.annotation.Nonnull
  public Integer getSTRINGPOSITION() {
    return STRING_POSITION;
  }

  public void setSTRINGPOSITION(@javax.annotation.Nonnull Integer STRING_POSITION) {
    this.STRING_POSITION = STRING_POSITION;
  }

  public StringItem SYMBOLS_PARAM(@javax.annotation.Nonnull Integer SYMBOLS_PARAM) {
    this.SYMBOLS_PARAM = SYMBOLS_PARAM;
    return this;
  }

  /**
   * Get SYMBOLS_PARAM
   *
   * @return SYMBOLS_PARAM
   */
  @javax.annotation.Nonnull
  public Integer getSYMBOLSPARAM() {
    return SYMBOLS_PARAM;
  }

  public void setSYMBOLSPARAM(@javax.annotation.Nonnull Integer SYMBOLS_PARAM) {
    this.SYMBOLS_PARAM = SYMBOLS_PARAM;
  }

  public StringItem sizeErrorALIGNMENT(@javax.annotation.Nonnull Integer sizeErrorALIGNMENT) {
    this.sizeErrorALIGNMENT = sizeErrorALIGNMENT;
    return this;
  }

  /**
   * Get sizeErrorALIGNMENT
   *
   * @return sizeErrorALIGNMENT
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorALIGNMENT() {
    return sizeErrorALIGNMENT;
  }

  public void setSizeErrorALIGNMENT(@javax.annotation.Nonnull Integer sizeErrorALIGNMENT) {
    this.sizeErrorALIGNMENT = sizeErrorALIGNMENT;
  }

  public StringItem sizeErrorDISTANCE(@javax.annotation.Nonnull Integer sizeErrorDISTANCE) {
    this.sizeErrorDISTANCE = sizeErrorDISTANCE;
    return this;
  }

  /**
   * Get sizeErrorDISTANCE
   *
   * @return sizeErrorDISTANCE
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorDISTANCE() {
    return sizeErrorDISTANCE;
  }

  public void setSizeErrorDISTANCE(@javax.annotation.Nonnull Integer sizeErrorDISTANCE) {
    this.sizeErrorDISTANCE = sizeErrorDISTANCE;
  }

  public StringItem sizeErrorINTERVAL(@javax.annotation.Nonnull Integer sizeErrorINTERVAL) {
    this.sizeErrorINTERVAL = sizeErrorINTERVAL;
    return this;
  }

  /**
   * Get sizeErrorINTERVAL
   *
   * @return sizeErrorINTERVAL
   */
  @javax.annotation.Nonnull
  public Integer getSizeErrorINTERVAL() {
    return sizeErrorINTERVAL;
  }

  public void setSizeErrorINTERVAL(@javax.annotation.Nonnull Integer sizeErrorINTERVAL) {
    this.sizeErrorINTERVAL = sizeErrorINTERVAL;
  }

  public StringItem stringAngle(@javax.annotation.Nonnull Integer stringAngle) {
    this.stringAngle = stringAngle;
    return this;
  }

  /**
   * Get stringAngle
   *
   * @return stringAngle
   */
  @javax.annotation.Nonnull
  public Integer getStringAngle() {
    return stringAngle;
  }

  public void setStringAngle(@javax.annotation.Nonnull Integer stringAngle) {
    this.stringAngle = stringAngle;
  }

  public StringItem stringBorders(@javax.annotation.Nonnull RectangleCoordinates stringBorders) {
    this.stringBorders = stringBorders;
    return this;
  }

  /**
   * Get stringBorders
   *
   * @return stringBorders
   */
  @javax.annotation.Nonnull
  public RectangleCoordinates getStringBorders() {
    return stringBorders;
  }

  public void setStringBorders(@javax.annotation.Nonnull RectangleCoordinates stringBorders) {
    this.stringBorders = stringBorders;
  }

  public StringItem symbolsCount(@javax.annotation.Nonnull Integer symbolsCount) {
    this.symbolsCount = symbolsCount;
    return this;
  }

  /**
   * Get symbolsCount
   *
   * @return symbolsCount
   */
  @javax.annotation.Nonnull
  public Integer getSymbolsCount() {
    return symbolsCount;
  }

  public void setSymbolsCount(@javax.annotation.Nonnull Integer symbolsCount) {
    this.symbolsCount = symbolsCount;
  }

  public StringItem symbolsEstimations(
      @javax.annotation.Nonnull List<SymbolEstimationItem> symbolsEstimations) {
    this.symbolsEstimations = symbolsEstimations;
    return this;
  }

  public StringItem addSymbolsEstimationsItem(SymbolEstimationItem symbolsEstimationsItem) {
    if (this.symbolsEstimations == null) {
      this.symbolsEstimations = new ArrayList<>();
    }
    this.symbolsEstimations.add(symbolsEstimationsItem);
    return this;
  }

  /**
   * Get symbolsEstimations
   *
   * @return symbolsEstimations
   */
  @javax.annotation.Nonnull
  public List<SymbolEstimationItem> getSymbolsEstimations() {
    return symbolsEstimations;
  }

  public void setSymbolsEstimations(
      @javax.annotation.Nonnull List<SymbolEstimationItem> symbolsEstimations) {
    this.symbolsEstimations = symbolsEstimations;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    StringItem stringItem = (StringItem) o;
    return Objects.equals(this.ALIGNMENT_SYMBOLS_IN_STRING, stringItem.ALIGNMENT_SYMBOLS_IN_STRING)
        && Objects.equals(this.CHECK_SUMS, stringItem.CHECK_SUMS)
        && Objects.equals(this.errorPOSITION, stringItem.errorPOSITION)
        && Objects.equals(this.fieldCount, stringItem.fieldCount)
        && Objects.equals(this.fields, stringItem.fields)
        && Objects.equals(this.STRINGS_DISTANCE, stringItem.STRINGS_DISTANCE)
        && Objects.equals(this.STRINGS_INTERVAL, stringItem.STRINGS_INTERVAL)
        && Objects.equals(this.STRING_FILLING, stringItem.STRING_FILLING)
        && Objects.equals(this.STRING_POSITION, stringItem.STRING_POSITION)
        && Objects.equals(this.SYMBOLS_PARAM, stringItem.SYMBOLS_PARAM)
        && Objects.equals(this.sizeErrorALIGNMENT, stringItem.sizeErrorALIGNMENT)
        && Objects.equals(this.sizeErrorDISTANCE, stringItem.sizeErrorDISTANCE)
        && Objects.equals(this.sizeErrorINTERVAL, stringItem.sizeErrorINTERVAL)
        && Objects.equals(this.stringAngle, stringItem.stringAngle)
        && Objects.equals(this.stringBorders, stringItem.stringBorders)
        && Objects.equals(this.symbolsCount, stringItem.symbolsCount)
        && Objects.equals(this.symbolsEstimations, stringItem.symbolsEstimations);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        ALIGNMENT_SYMBOLS_IN_STRING,
        CHECK_SUMS,
        errorPOSITION,
        fieldCount,
        fields,
        STRINGS_DISTANCE,
        STRINGS_INTERVAL,
        STRING_FILLING,
        STRING_POSITION,
        SYMBOLS_PARAM,
        sizeErrorALIGNMENT,
        sizeErrorDISTANCE,
        sizeErrorINTERVAL,
        stringAngle,
        stringBorders,
        symbolsCount,
        symbolsEstimations);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class StringItem {\n");
    sb.append("    ALIGNMENT_SYMBOLS_IN_STRING: ")
        .append(toIndentedString(ALIGNMENT_SYMBOLS_IN_STRING))
        .append("\n");
    sb.append("    CHECK_SUMS: ").append(toIndentedString(CHECK_SUMS)).append("\n");
    sb.append("    errorPOSITION: ").append(toIndentedString(errorPOSITION)).append("\n");
    sb.append("    fieldCount: ").append(toIndentedString(fieldCount)).append("\n");
    sb.append("    fields: ").append(toIndentedString(fields)).append("\n");
    sb.append("    STRINGS_DISTANCE: ").append(toIndentedString(STRINGS_DISTANCE)).append("\n");
    sb.append("    STRINGS_INTERVAL: ").append(toIndentedString(STRINGS_INTERVAL)).append("\n");
    sb.append("    STRING_FILLING: ").append(toIndentedString(STRING_FILLING)).append("\n");
    sb.append("    STRING_POSITION: ").append(toIndentedString(STRING_POSITION)).append("\n");
    sb.append("    SYMBOLS_PARAM: ").append(toIndentedString(SYMBOLS_PARAM)).append("\n");
    sb.append("    sizeErrorALIGNMENT: ").append(toIndentedString(sizeErrorALIGNMENT)).append("\n");
    sb.append("    sizeErrorDISTANCE: ").append(toIndentedString(sizeErrorDISTANCE)).append("\n");
    sb.append("    sizeErrorINTERVAL: ").append(toIndentedString(sizeErrorINTERVAL)).append("\n");
    sb.append("    stringAngle: ").append(toIndentedString(stringAngle)).append("\n");
    sb.append("    stringBorders: ").append(toIndentedString(stringBorders)).append("\n");
    sb.append("    symbolsCount: ").append(toIndentedString(symbolsCount)).append("\n");
    sb.append("    symbolsEstimations: ").append(toIndentedString(symbolsEstimations)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("ALIGNMENT_SYMBOLS_IN_STRING");
    openapiFields.add("CHECK_SUMS");
    openapiFields.add("ErrorPOSITION");
    openapiFields.add("FieldCount");
    openapiFields.add("Fields");
    openapiFields.add("STRINGS_DISTANCE");
    openapiFields.add("STRINGS_INTERVAL");
    openapiFields.add("STRING_FILLING");
    openapiFields.add("STRING_POSITION");
    openapiFields.add("SYMBOLS_PARAM");
    openapiFields.add("SizeError_ALIGNMENT");
    openapiFields.add("SizeError_DISTANCE");
    openapiFields.add("SizeError_INTERVAL");
    openapiFields.add("StringAngle");
    openapiFields.add("StringBorders");
    openapiFields.add("SymbolsCount");
    openapiFields.add("SymbolsEstimations");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("ALIGNMENT_SYMBOLS_IN_STRING");
    openapiRequiredFields.add("CHECK_SUMS");
    openapiRequiredFields.add("ErrorPOSITION");
    openapiRequiredFields.add("FieldCount");
    openapiRequiredFields.add("Fields");
    openapiRequiredFields.add("STRINGS_DISTANCE");
    openapiRequiredFields.add("STRINGS_INTERVAL");
    openapiRequiredFields.add("STRING_FILLING");
    openapiRequiredFields.add("STRING_POSITION");
    openapiRequiredFields.add("SYMBOLS_PARAM");
    openapiRequiredFields.add("SizeError_ALIGNMENT");
    openapiRequiredFields.add("SizeError_DISTANCE");
    openapiRequiredFields.add("SizeError_INTERVAL");
    openapiRequiredFields.add("StringAngle");
    openapiRequiredFields.add("StringBorders");
    openapiRequiredFields.add("SymbolsCount");
    openapiRequiredFields.add("SymbolsEstimations");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to StringItem
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
    if (jsonElement == null) {
      if (!StringItem.openapiRequiredFields
          .isEmpty()) { // has required fields but JSON element is null
        throw new IllegalArgumentException(
            String.format(
                "The required field(s) %s in StringItem is not found in the empty JSON string",
                StringItem.openapiRequiredFields.toString()));
      }
    }

    Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
    // check to see if the JSON string contains additional fields
    for (Map.Entry<String, JsonElement> entry : entries) {
      if (!StringItem.openapiFields.contains(entry.getKey())) {
        throw new IllegalArgumentException(
            String.format(
                "The field `%s` in the JSON string is not defined in the `StringItem` properties. JSON: %s",
                entry.getKey(), jsonElement.toString()));
      }
    }

    // check to make sure all required properties/fields are present in the JSON string
    for (String requiredField : StringItem.openapiRequiredFields) {
      if (jsonElement.getAsJsonObject().get(requiredField) == null) {
        throw new IllegalArgumentException(
            String.format(
                "The required field `%s` is not found in the JSON string: %s",
                requiredField, jsonElement.toString()));
      }
    }
    JsonObject jsonObj = jsonElement.getAsJsonObject();
    // validate the required field `ErrorPOSITION`
    ErrorCoordinates.validateJsonElement(jsonObj.get("ErrorPOSITION"));
    // ensure the json data is an array
    if (!jsonObj.get("Fields").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `Fields` to be an array in the JSON string but got `%s`",
              jsonObj.get("Fields").toString()));
    }

    JsonArray jsonArrayfields = jsonObj.getAsJsonArray("Fields");
    // validate the required field `Fields` (array)
    for (int i = 0; i < jsonArrayfields.size(); i++) {
      FieldItem.validateJsonElement(jsonArrayfields.get(i));
    }
    ;
    // validate the required field `StringBorders`
    RectangleCoordinates.validateJsonElement(jsonObj.get("StringBorders"));
    // ensure the json data is an array
    if (!jsonObj.get("SymbolsEstimations").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `SymbolsEstimations` to be an array in the JSON string but got `%s`",
              jsonObj.get("SymbolsEstimations").toString()));
    }

    JsonArray jsonArraysymbolsEstimations = jsonObj.getAsJsonArray("SymbolsEstimations");
    // validate the required field `SymbolsEstimations` (array)
    for (int i = 0; i < jsonArraysymbolsEstimations.size(); i++) {
      SymbolEstimationItem.validateJsonElement(jsonArraysymbolsEstimations.get(i));
    }
    ;
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
      if (!StringItem.class.isAssignableFrom(type.getRawType())) {
        return null; // this class only serializes 'StringItem' and its subtypes
      }
      final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
      final TypeAdapter<StringItem> thisAdapter =
          gson.getDelegateAdapter(this, TypeToken.get(StringItem.class));

      return (TypeAdapter<T>)
          new TypeAdapter<StringItem>() {
            @Override
            public void write(JsonWriter out, StringItem value) throws IOException {
              JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
              elementAdapter.write(out, obj);
            }

            @Override
            public StringItem read(JsonReader in) throws IOException {
              JsonElement jsonElement = elementAdapter.read(in);
              validateJsonElement(jsonElement);
              return thisAdapter.fromJsonTree(jsonElement);
            }
          }.nullSafe();
    }
  }

  /**
   * Create an instance of StringItem given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of StringItem
   * @throws IOException if the JSON string is invalid with respect to StringItem
   */
  public static StringItem fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, StringItem.class);
  }

  /**
   * Convert an instance of StringItem to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
