/*
 * Regula Document Reader Web API
 * Documents recognition as easy as reading two bytes.   # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core
 *
 * The version of the OpenAPI document: 7.6.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.regula.documentreader.webclient.model;

import com.google.gson.Gson;
import com.google.gson.JsonArray;
import com.google.gson.JsonElement;
import com.google.gson.JsonObject;
import com.google.gson.TypeAdapter;
import com.google.gson.TypeAdapterFactory;
import com.google.gson.annotations.SerializedName;
import com.google.gson.reflect.TypeToken;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import com.regula.documentreader.webclient.JSON;
import java.io.IOException;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.HashSet;
import java.util.List;
import java.util.Map;
import java.util.Objects;
import java.util.Set;

/** ProcessParams */
@javax.annotation.Generated(
    value = "org.openapitools.codegen.languages.JavaClientCodegen",
    comments = "Generator version: 7.12.0")
public class ProcessParams {
  public static final String SERIALIZED_NAME_GENERATE_D_T_C_V_C = "generateDTCVC";

  @SerializedName(SERIALIZED_NAME_GENERATE_D_T_C_V_C)
  @javax.annotation.Nullable
  private Boolean generateDTCVC;

  public static final String SERIALIZED_NAME_LCID_FILTER = "lcidFilter";

  @SerializedName(SERIALIZED_NAME_LCID_FILTER)
  @javax.annotation.Nullable
  private List<LCID> lcidFilter;

  public static final String SERIALIZED_NAME_CHECK_LIVENESS = "checkLiveness";

  @SerializedName(SERIALIZED_NAME_CHECK_LIVENESS)
  @javax.annotation.Nullable
  private Boolean checkLiveness;

  public static final String SERIALIZED_NAME_LCID_IGNORE_FILTER = "lcidIgnoreFilter";

  @SerializedName(SERIALIZED_NAME_LCID_IGNORE_FILTER)
  @javax.annotation.Nullable
  private List<LCID> lcidIgnoreFilter;

  public static final String SERIALIZED_NAME_ONE_SHOT_IDENTIFICATION = "oneShotIdentification";

  @SerializedName(SERIALIZED_NAME_ONE_SHOT_IDENTIFICATION)
  @javax.annotation.Nullable
  private Boolean oneShotIdentification;

  public static final String SERIALIZED_NAME_USE_FACE_API = "useFaceApi";

  @SerializedName(SERIALIZED_NAME_USE_FACE_API)
  @javax.annotation.Nullable
  private Boolean useFaceApi;

  public static final String SERIALIZED_NAME_FACE_API = "faceApi";

  @SerializedName(SERIALIZED_NAME_FACE_API)
  @javax.annotation.Nullable
  private FaceApi faceApi;

  public static final String SERIALIZED_NAME_DO_DETECT_CAN = "doDetectCan";

  @SerializedName(SERIALIZED_NAME_DO_DETECT_CAN)
  @javax.annotation.Nullable
  private Boolean doDetectCan;

  public static final String SERIALIZED_NAME_IMAGE_OUTPUT_MAX_HEIGHT = "imageOutputMaxHeight";

  @SerializedName(SERIALIZED_NAME_IMAGE_OUTPUT_MAX_HEIGHT)
  @javax.annotation.Nullable
  private Integer imageOutputMaxHeight;

  public static final String SERIALIZED_NAME_IMAGE_OUTPUT_MAX_WIDTH = "imageOutputMaxWidth";

  @SerializedName(SERIALIZED_NAME_IMAGE_OUTPUT_MAX_WIDTH)
  @javax.annotation.Nullable
  private Integer imageOutputMaxWidth;

  public static final String SERIALIZED_NAME_SCENARIO = "scenario";

  @SerializedName(SERIALIZED_NAME_SCENARIO)
  @javax.annotation.Nonnull
  private Scenario scenario;

  public static final String SERIALIZED_NAME_RESULT_TYPE_OUTPUT = "resultTypeOutput";

  @SerializedName(SERIALIZED_NAME_RESULT_TYPE_OUTPUT)
  @javax.annotation.Nullable
  private List<Result> resultTypeOutput;

  public static final String SERIALIZED_NAME_DOUBLE_PAGE_SPREAD = "doublePageSpread";

  @Deprecated
  @SerializedName(SERIALIZED_NAME_DOUBLE_PAGE_SPREAD)
  @javax.annotation.Nullable
  private Boolean doublePageSpread;

  public static final String SERIALIZED_NAME_GENERATE_DOUBLE_PAGE_SPREAD_IMAGE =
      "generateDoublePageSpreadImage";

  @SerializedName(SERIALIZED_NAME_GENERATE_DOUBLE_PAGE_SPREAD_IMAGE)
  @javax.annotation.Nullable
  private Boolean generateDoublePageSpreadImage;

  public static final String SERIALIZED_NAME_FIELD_TYPES_FILTER = "fieldTypesFilter";

  @SerializedName(SERIALIZED_NAME_FIELD_TYPES_FILTER)
  @javax.annotation.Nullable
  private List<TextFieldType> fieldTypesFilter;

  public static final String SERIALIZED_NAME_DATE_FORMAT = "dateFormat";

  @SerializedName(SERIALIZED_NAME_DATE_FORMAT)
  @javax.annotation.Nullable
  private String dateFormat;

  public static final String SERIALIZED_NAME_MEASURE_SYSTEM = "measureSystem";

  @SerializedName(SERIALIZED_NAME_MEASURE_SYSTEM)
  @javax.annotation.Nullable
  private MeasureSystem measureSystem;

  public static final String SERIALIZED_NAME_IMAGE_DPI_OUT_MAX = "imageDpiOutMax";

  @SerializedName(SERIALIZED_NAME_IMAGE_DPI_OUT_MAX)
  @javax.annotation.Nullable
  private Integer imageDpiOutMax;

  public static final String SERIALIZED_NAME_ALREADY_CROPPED = "alreadyCropped";

  @SerializedName(SERIALIZED_NAME_ALREADY_CROPPED)
  @javax.annotation.Nullable
  private Boolean alreadyCropped;

  public static final String SERIALIZED_NAME_CUSTOM_PARAMS = "customParams";

  @SerializedName(SERIALIZED_NAME_CUSTOM_PARAMS)
  @javax.annotation.Nullable
  private Map<String, Object> customParams;

  public static final String SERIALIZED_NAME_CONFIG = "config";

  @SerializedName(SERIALIZED_NAME_CONFIG)
  @javax.annotation.Nullable
  private List<PerDocumentConfig> config;

  public static final String SERIALIZED_NAME_LOG = "log";

  @SerializedName(SERIALIZED_NAME_LOG)
  @javax.annotation.Nullable
  private Boolean log;

  public static final String SERIALIZED_NAME_LOG_LEVEL = "logLevel";

  @SerializedName(SERIALIZED_NAME_LOG_LEVEL)
  @javax.annotation.Nullable
  private LogLevel logLevel;

  public static final String SERIALIZED_NAME_FORCE_DOC_I_D = "forceDocID";

  @SerializedName(SERIALIZED_NAME_FORCE_DOC_I_D)
  @javax.annotation.Nullable
  private Integer forceDocID;

  public static final String SERIALIZED_NAME_MATCH_TEXT_FIELD_MASK = "matchTextFieldMask";

  @SerializedName(SERIALIZED_NAME_MATCH_TEXT_FIELD_MASK)
  @javax.annotation.Nullable
  private Boolean matchTextFieldMask;

  public static final String SERIALIZED_NAME_FAST_DOC_DETECT = "fastDocDetect";

  @Deprecated
  @SerializedName(SERIALIZED_NAME_FAST_DOC_DETECT)
  @javax.annotation.Nullable
  private Boolean fastDocDetect;

  public static final String SERIALIZED_NAME_UPDATE_O_C_R_VALIDITY_BY_GLARE =
      "updateOCRValidityByGlare";

  @SerializedName(SERIALIZED_NAME_UPDATE_O_C_R_VALIDITY_BY_GLARE)
  @javax.annotation.Nullable
  private Boolean updateOCRValidityByGlare;

  public static final String SERIALIZED_NAME_CHECK_REQUIRED_TEXT_FIELDS = "checkRequiredTextFields";

  @SerializedName(SERIALIZED_NAME_CHECK_REQUIRED_TEXT_FIELDS)
  @javax.annotation.Nullable
  private Boolean checkRequiredTextFields;

  public static final String SERIALIZED_NAME_RETURN_CROPPED_BARCODE = "returnCroppedBarcode";

  @SerializedName(SERIALIZED_NAME_RETURN_CROPPED_BARCODE)
  @javax.annotation.Nullable
  private Boolean returnCroppedBarcode;

  public static final String SERIALIZED_NAME_IMAGE_QA = "imageQa";

  @SerializedName(SERIALIZED_NAME_IMAGE_QA)
  @javax.annotation.Nullable
  private ImageQA imageQa;

  public static final String SERIALIZED_NAME_STRICT_IMAGE_QUALITY = "strictImageQuality";

  @SerializedName(SERIALIZED_NAME_STRICT_IMAGE_QUALITY)
  @javax.annotation.Nullable
  private Boolean strictImageQuality;

  public static final String SERIALIZED_NAME_RESPECT_IMAGE_QUALITY = "respectImageQuality";

  @Deprecated
  @SerializedName(SERIALIZED_NAME_RESPECT_IMAGE_QUALITY)
  @javax.annotation.Nullable
  private Boolean respectImageQuality;

  public static final String SERIALIZED_NAME_FORCE_DOC_FORMAT = "forceDocFormat";

  @SerializedName(SERIALIZED_NAME_FORCE_DOC_FORMAT)
  @javax.annotation.Nullable
  private DocumentFormat forceDocFormat;

  public static final String SERIALIZED_NAME_NO_GRAPHICS = "noGraphics";

  @SerializedName(SERIALIZED_NAME_NO_GRAPHICS)
  @javax.annotation.Nullable
  private Boolean noGraphics;

  public static final String SERIALIZED_NAME_DEPERSONALIZE_LOG = "depersonalizeLog";

  @SerializedName(SERIALIZED_NAME_DEPERSONALIZE_LOG)
  @javax.annotation.Nullable
  private Boolean depersonalizeLog;

  public static final String SERIALIZED_NAME_MULTI_DOC_ON_IMAGE = "multiDocOnImage";

  @SerializedName(SERIALIZED_NAME_MULTI_DOC_ON_IMAGE)
  @javax.annotation.Nullable
  private Boolean multiDocOnImage;

  public static final String SERIALIZED_NAME_SHIFT_EXPIRY_DATE = "shiftExpiryDate";

  @SerializedName(SERIALIZED_NAME_SHIFT_EXPIRY_DATE)
  @javax.annotation.Nullable
  private Integer shiftExpiryDate;

  public static final String SERIALIZED_NAME_MINIMAL_HOLDER_AGE = "minimalHolderAge";

  @SerializedName(SERIALIZED_NAME_MINIMAL_HOLDER_AGE)
  @javax.annotation.Nullable
  private Integer minimalHolderAge;

  public static final String SERIALIZED_NAME_RETURN_UNCROPPED_IMAGE = "returnUncroppedImage";

  @SerializedName(SERIALIZED_NAME_RETURN_UNCROPPED_IMAGE)
  @javax.annotation.Nullable
  private Boolean returnUncroppedImage;

  public static final String SERIALIZED_NAME_MRZ_FORMATS_FILTER = "mrzFormatsFilter";

  @SerializedName(SERIALIZED_NAME_MRZ_FORMATS_FILTER)
  @javax.annotation.Nullable
  private List<MRZFormat> mrzFormatsFilter;

  public static final String SERIALIZED_NAME_FORCE_READ_MRZ_BEFORE_LOCATE =
      "forceReadMrzBeforeLocate";

  @SerializedName(SERIALIZED_NAME_FORCE_READ_MRZ_BEFORE_LOCATE)
  @javax.annotation.Nullable
  private Boolean forceReadMrzBeforeLocate;

  public static final String SERIALIZED_NAME_PARSE_BARCODES = "parseBarcodes";

  @SerializedName(SERIALIZED_NAME_PARSE_BARCODES)
  @javax.annotation.Nullable
  private Boolean parseBarcodes;

  public static final String SERIALIZED_NAME_CONVERT_CASE = "convertCase";

  @SerializedName(SERIALIZED_NAME_CONVERT_CASE)
  @javax.annotation.Nullable
  private TextPostProcessing convertCase;

  public static final String SERIALIZED_NAME_SPLIT_NAMES = "splitNames";

  @SerializedName(SERIALIZED_NAME_SPLIT_NAMES)
  @javax.annotation.Nullable
  private Boolean splitNames;

  public static final String SERIALIZED_NAME_DISABLE_PERFORATION_O_C_R = "disablePerforationOCR";

  @SerializedName(SERIALIZED_NAME_DISABLE_PERFORATION_O_C_R)
  @javax.annotation.Nullable
  private Boolean disablePerforationOCR;

  public static final String SERIALIZED_NAME_DOCUMENT_GROUP_FILTER = "documentGroupFilter";

  @SerializedName(SERIALIZED_NAME_DOCUMENT_GROUP_FILTER)
  @javax.annotation.Nullable
  private List<DocumentType> documentGroupFilter;

  public static final String SERIALIZED_NAME_PROCESS_AUTH = "processAuth";

  @SerializedName(SERIALIZED_NAME_PROCESS_AUTH)
  @javax.annotation.Nullable
  private Long processAuth;

  public static final String SERIALIZED_NAME_DEVICE_ID = "deviceId";

  @SerializedName(SERIALIZED_NAME_DEVICE_ID)
  @javax.annotation.Nullable
  private Integer deviceId;

  public static final String SERIALIZED_NAME_DEVICE_TYPE = "deviceType";

  @SerializedName(SERIALIZED_NAME_DEVICE_TYPE)
  @javax.annotation.Nullable
  private Integer deviceType;

  public static final String SERIALIZED_NAME_DEVICE_TYPE_HEX = "deviceTypeHex";

  @SerializedName(SERIALIZED_NAME_DEVICE_TYPE_HEX)
  @javax.annotation.Nullable
  private String deviceTypeHex;

  public static final String SERIALIZED_NAME_IGNORE_DEVICE_ID_FROM_IMAGE =
      "ignoreDeviceIdFromImage";

  @SerializedName(SERIALIZED_NAME_IGNORE_DEVICE_ID_FROM_IMAGE)
  @javax.annotation.Nullable
  private Boolean ignoreDeviceIdFromImage;

  public static final String SERIALIZED_NAME_DOCUMENT_ID_LIST = "documentIdList";

  @SerializedName(SERIALIZED_NAME_DOCUMENT_ID_LIST)
  @javax.annotation.Nullable
  private List<Integer> documentIdList;

  public static final String SERIALIZED_NAME_RFID = "rfid";

  @SerializedName(SERIALIZED_NAME_RFID)
  @javax.annotation.Nullable
  private ProcessParamsRfid rfid;

  public static final String SERIALIZED_NAME_CHECK_AUTH = "checkAuth";

  @SerializedName(SERIALIZED_NAME_CHECK_AUTH)
  @javax.annotation.Nullable
  private Boolean checkAuth;

  public static final String SERIALIZED_NAME_AUTH_PARAMS = "authParams";

  @SerializedName(SERIALIZED_NAME_AUTH_PARAMS)
  @javax.annotation.Nullable
  private AuthParams authParams;

  public static final String SERIALIZED_NAME_MRZ_DETECT_MODE = "mrzDetectMode";

  @SerializedName(SERIALIZED_NAME_MRZ_DETECT_MODE)
  @javax.annotation.Nullable
  private MrzDetectModeEnum mrzDetectMode;

  public static final String SERIALIZED_NAME_GENERATE_NUMERIC_CODES = "generateNumericCodes";

  @SerializedName(SERIALIZED_NAME_GENERATE_NUMERIC_CODES)
  @javax.annotation.Nullable
  private Boolean generateNumericCodes;

  public static final String SERIALIZED_NAME_STRICT_BARCODE_DIGITAL_SIGNATURE_CHECK =
      "strictBarcodeDigitalSignatureCheck";

  @SerializedName(SERIALIZED_NAME_STRICT_BARCODE_DIGITAL_SIGNATURE_CHECK)
  @javax.annotation.Nullable
  private Boolean strictBarcodeDigitalSignatureCheck;

  public static final String SERIALIZED_NAME_SELECT_LONGEST_NAMES = "selectLongestNames";

  @SerializedName(SERIALIZED_NAME_SELECT_LONGEST_NAMES)
  @javax.annotation.Nullable
  private Boolean selectLongestNames;

  public static final String SERIALIZED_NAME_DO_BARCODES = "doBarcodes";

  @SerializedName(SERIALIZED_NAME_DO_BARCODES)
  @javax.annotation.Nullable
  private List<InputBarcodeType> doBarcodes;

  public ProcessParams() {}

  public ProcessParams generateDTCVC(@javax.annotation.Nullable Boolean generateDTCVC) {
    this.generateDTCVC = generateDTCVC;
    return this;
  }

  /**
   * This parameter is used to generate separate DTC-VC data container from RFID session data.
   *
   * @return generateDTCVC
   */
  @javax.annotation.Nullable
  public Boolean getGenerateDTCVC() {
    return generateDTCVC;
  }

  public void setGenerateDTCVC(@javax.annotation.Nullable Boolean generateDTCVC) {
    this.generateDTCVC = generateDTCVC;
  }

  public ProcessParams lcidFilter(@javax.annotation.Nullable List<LCID> lcidFilter) {
    this.lcidFilter = lcidFilter;
    return this;
  }

  public ProcessParams addLcidFilterItem(LCID lcidFilterItem) {
    if (this.lcidFilter == null) {
      this.lcidFilter = new ArrayList<>();
    }
    this.lcidFilter.add(lcidFilterItem);
    return this;
  }

  /**
   * The list of LCID types to recognize. If empty, values with all LCID types will be extracted.
   * Empty by default.
   *
   * @return lcidFilter
   */
  @javax.annotation.Nullable
  public List<LCID> getLcidFilter() {
    return lcidFilter;
  }

  public void setLcidFilter(@javax.annotation.Nullable List<LCID> lcidFilter) {
    this.lcidFilter = lcidFilter;
  }

  public ProcessParams checkLiveness(@javax.annotation.Nullable Boolean checkLiveness) {
    this.checkLiveness = checkLiveness;
    return this;
  }

  /**
   * This parameter is used to enable document liveness check.
   *
   * @return checkLiveness
   */
  @javax.annotation.Nullable
  public Boolean getCheckLiveness() {
    return checkLiveness;
  }

  public void setCheckLiveness(@javax.annotation.Nullable Boolean checkLiveness) {
    this.checkLiveness = checkLiveness;
  }

  public ProcessParams lcidIgnoreFilter(@javax.annotation.Nullable List<LCID> lcidIgnoreFilter) {
    this.lcidIgnoreFilter = lcidIgnoreFilter;
    return this;
  }

  public ProcessParams addLcidIgnoreFilterItem(LCID lcidIgnoreFilterItem) {
    if (this.lcidIgnoreFilter == null) {
      this.lcidIgnoreFilter = new ArrayList<>();
    }
    this.lcidIgnoreFilter.add(lcidIgnoreFilterItem);
    return this;
  }

  /**
   * The list of LCID types to ignore during the recognition. If empty, values with all LCID types
   * will be extracted. Narrowing down the list can reduce processing time. Empty by default.
   *
   * @return lcidIgnoreFilter
   */
  @javax.annotation.Nullable
  public List<LCID> getLcidIgnoreFilter() {
    return lcidIgnoreFilter;
  }

  public void setLcidIgnoreFilter(@javax.annotation.Nullable List<LCID> lcidIgnoreFilter) {
    this.lcidIgnoreFilter = lcidIgnoreFilter;
  }

  public ProcessParams oneShotIdentification(
      @javax.annotation.Nullable Boolean oneShotIdentification) {
    this.oneShotIdentification = oneShotIdentification;
    return this;
  }

  /**
   * This parameter allows processing an image that contains a person and a document and compare the
   * portrait photo from the document with the person&#39;s face
   *
   * @return oneShotIdentification
   */
  @javax.annotation.Nullable
  public Boolean getOneShotIdentification() {
    return oneShotIdentification;
  }

  public void setOneShotIdentification(@javax.annotation.Nullable Boolean oneShotIdentification) {
    this.oneShotIdentification = oneShotIdentification;
  }

  public ProcessParams useFaceApi(@javax.annotation.Nullable Boolean useFaceApi) {
    this.useFaceApi = useFaceApi;
    return this;
  }

  /**
   * This parameter allows comparing faces on Regula Face Web Service
   *
   * @return useFaceApi
   */
  @javax.annotation.Nullable
  public Boolean getUseFaceApi() {
    return useFaceApi;
  }

  public void setUseFaceApi(@javax.annotation.Nullable Boolean useFaceApi) {
    this.useFaceApi = useFaceApi;
  }

  public ProcessParams faceApi(@javax.annotation.Nullable FaceApi faceApi) {
    this.faceApi = faceApi;
    return this;
  }

  /**
   * Get faceApi
   *
   * @return faceApi
   */
  @javax.annotation.Nullable
  public FaceApi getFaceApi() {
    return faceApi;
  }

  public void setFaceApi(@javax.annotation.Nullable FaceApi faceApi) {
    this.faceApi = faceApi;
  }

  public ProcessParams doDetectCan(@javax.annotation.Nullable Boolean doDetectCan) {
    this.doDetectCan = doDetectCan;
    return this;
  }

  /**
   * This parameter allows enabling the CAN (Card Access Number) detection and recognition when
   * using scenarios with document location and MRZ reading, such as the MrzAndLocate scenario.
   *
   * @return doDetectCan
   */
  @javax.annotation.Nullable
  public Boolean getDoDetectCan() {
    return doDetectCan;
  }

  public void setDoDetectCan(@javax.annotation.Nullable Boolean doDetectCan) {
    this.doDetectCan = doDetectCan;
  }

  public ProcessParams imageOutputMaxHeight(
      @javax.annotation.Nullable Integer imageOutputMaxHeight) {
    this.imageOutputMaxHeight = imageOutputMaxHeight;
    return this;
  }

  /**
   * This parameter allows setting maximum height in pixels of output images and thus reducing image
   * size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.
   *
   * @return imageOutputMaxHeight
   */
  @javax.annotation.Nullable
  public Integer getImageOutputMaxHeight() {
    return imageOutputMaxHeight;
  }

  public void setImageOutputMaxHeight(@javax.annotation.Nullable Integer imageOutputMaxHeight) {
    this.imageOutputMaxHeight = imageOutputMaxHeight;
  }

  public ProcessParams imageOutputMaxWidth(@javax.annotation.Nullable Integer imageOutputMaxWidth) {
    this.imageOutputMaxWidth = imageOutputMaxWidth;
    return this;
  }

  /**
   * This parameter allows setting maximum width in pixels of output images and thus reducing image
   * size to desired. Does not change the aspect ratio. Changes disabled if equals to 0. Default 0.
   *
   * @return imageOutputMaxWidth
   */
  @javax.annotation.Nullable
  public Integer getImageOutputMaxWidth() {
    return imageOutputMaxWidth;
  }

  public void setImageOutputMaxWidth(@javax.annotation.Nullable Integer imageOutputMaxWidth) {
    this.imageOutputMaxWidth = imageOutputMaxWidth;
  }

  public ProcessParams scenario(@javax.annotation.Nonnull Scenario scenario) {
    this.scenario = scenario;
    return this;
  }

  /**
   * Get scenario
   *
   * @return scenario
   */
  @javax.annotation.Nonnull
  public Scenario getScenario() {
    return scenario;
  }

  public void setScenario(@javax.annotation.Nonnull Scenario scenario) {
    this.scenario = scenario;
  }

  public ProcessParams resultTypeOutput(@javax.annotation.Nullable List<Result> resultTypeOutput) {
    this.resultTypeOutput = resultTypeOutput;
    return this;
  }

  public ProcessParams addResultTypeOutputItem(Result resultTypeOutputItem) {
    if (this.resultTypeOutput == null) {
      this.resultTypeOutput = new ArrayList<>();
    }
    this.resultTypeOutput.add(resultTypeOutputItem);
    return this;
  }

  /**
   * Types of results to return in response. See &#39;Result&#39; enum for available options
   *
   * @return resultTypeOutput
   */
  @javax.annotation.Nullable
  public List<Result> getResultTypeOutput() {
    return resultTypeOutput;
  }

  public void setResultTypeOutput(@javax.annotation.Nullable List<Result> resultTypeOutput) {
    this.resultTypeOutput = resultTypeOutput;
  }

  @Deprecated
  public ProcessParams doublePageSpread(@javax.annotation.Nullable Boolean doublePageSpread) {
    this.doublePageSpread = doublePageSpread;
    return this;
  }

  /**
   * Enable this option if the image you provide contains double page spread of the passport and you
   * want to process both pages in one go. It makes sense to use it for documents that have
   * meaningful information on both pages, like Russian domestic passport, or some others. Disabled
   * by default.
   *
   * @return doublePageSpread
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getDoublePageSpread() {
    return doublePageSpread;
  }

  @Deprecated
  public void setDoublePageSpread(@javax.annotation.Nullable Boolean doublePageSpread) {
    this.doublePageSpread = doublePageSpread;
  }

  public ProcessParams generateDoublePageSpreadImage(
      @javax.annotation.Nullable Boolean generateDoublePageSpreadImage) {
    this.generateDoublePageSpreadImage = generateDoublePageSpreadImage;
    return this;
  }

  /**
   * When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two
   * pages spread in the image, pages will be cropped, straightened and aligned together, as if the
   * document was captured on a flatbed scanner. Disabled by default.
   *
   * @return generateDoublePageSpreadImage
   */
  @javax.annotation.Nullable
  public Boolean getGenerateDoublePageSpreadImage() {
    return generateDoublePageSpreadImage;
  }

  public void setGenerateDoublePageSpreadImage(
      @javax.annotation.Nullable Boolean generateDoublePageSpreadImage) {
    this.generateDoublePageSpreadImage = generateDoublePageSpreadImage;
  }

  public ProcessParams fieldTypesFilter(
      @javax.annotation.Nullable List<TextFieldType> fieldTypesFilter) {
    this.fieldTypesFilter = fieldTypesFilter;
    return this;
  }

  public ProcessParams addFieldTypesFilterItem(TextFieldType fieldTypesFilterItem) {
    if (this.fieldTypesFilter == null) {
      this.fieldTypesFilter = new ArrayList<>();
    }
    this.fieldTypesFilter.add(fieldTypesFilterItem);
    return this;
  }

  /**
   * List of text field types to extract. If empty, all text fields from template will be extracted.
   * Narrowing the list can shorten processing time. Empty by default.
   *
   * @return fieldTypesFilter
   */
  @javax.annotation.Nullable
  public List<TextFieldType> getFieldTypesFilter() {
    return fieldTypesFilter;
  }

  public void setFieldTypesFilter(@javax.annotation.Nullable List<TextFieldType> fieldTypesFilter) {
    this.fieldTypesFilter = fieldTypesFilter;
  }

  public ProcessParams dateFormat(@javax.annotation.Nullable String dateFormat) {
    this.dateFormat = dateFormat;
    return this;
  }

  /**
   * This option allows you to set dates format so that solution will return dates in this format.
   * For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL
   * 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it
   * is set to system locale default (where the service is running).
   *
   * @return dateFormat
   */
  @javax.annotation.Nullable
  public String getDateFormat() {
    return dateFormat;
  }

  public void setDateFormat(@javax.annotation.Nullable String dateFormat) {
    this.dateFormat = dateFormat;
  }

  public ProcessParams measureSystem(@javax.annotation.Nullable MeasureSystem measureSystem) {
    this.measureSystem = measureSystem;
    return this;
  }

  /**
   * Get measureSystem
   *
   * @return measureSystem
   */
  @javax.annotation.Nullable
  public MeasureSystem getMeasureSystem() {
    return measureSystem;
  }

  public void setMeasureSystem(@javax.annotation.Nullable MeasureSystem measureSystem) {
    this.measureSystem = measureSystem;
  }

  public ProcessParams imageDpiOutMax(@javax.annotation.Nullable Integer imageDpiOutMax) {
    this.imageDpiOutMax = imageDpiOutMax;
    return this;
  }

  /**
   * This parameter controls maximum resolution in dpi of output images. Resolution will remain
   * original in case 0 is supplied. By default is set to return images in response with resolution
   * not greater than 300 dpi for all scenarios except FullAuth. In FullAuth scenario this limit is
   * 1000 dpi by default.
   *
   * @return imageDpiOutMax
   */
  @javax.annotation.Nullable
  public Integer getImageDpiOutMax() {
    return imageDpiOutMax;
  }

  public void setImageDpiOutMax(@javax.annotation.Nullable Integer imageDpiOutMax) {
    this.imageDpiOutMax = imageDpiOutMax;
  }

  public ProcessParams alreadyCropped(@javax.annotation.Nullable Boolean alreadyCropped) {
    this.alreadyCropped = alreadyCropped;
    return this;
  }

  /**
   * This option can be enabled if you know for sure that the image you provide contains already
   * cropped document by its edges. This was designed to process on the server side images captured
   * and cropped on mobile. Disabled by default.
   *
   * @return alreadyCropped
   */
  @javax.annotation.Nullable
  public Boolean getAlreadyCropped() {
    return alreadyCropped;
  }

  public void setAlreadyCropped(@javax.annotation.Nullable Boolean alreadyCropped) {
    this.alreadyCropped = alreadyCropped;
  }

  public ProcessParams customParams(@javax.annotation.Nullable Map<String, Object> customParams) {
    this.customParams = customParams;
    return this;
  }

  public ProcessParams putCustomParamsItem(String key, Object customParamsItem) {
    if (this.customParams == null) {
      this.customParams = new HashMap<>();
    }
    this.customParams.put(key, customParamsItem);
    return this;
  }

  /**
   * This option allows passing custom processing parameters that can be implemented in future
   * without changing API.
   *
   * @return customParams
   */
  @javax.annotation.Nullable
  public Map<String, Object> getCustomParams() {
    return customParams;
  }

  public void setCustomParams(@javax.annotation.Nullable Map<String, Object> customParams) {
    this.customParams = customParams;
  }

  public ProcessParams config(@javax.annotation.Nullable List<PerDocumentConfig> config) {
    this.config = config;
    return this;
  }

  public ProcessParams addConfigItem(PerDocumentConfig configItem) {
    if (this.config == null) {
      this.config = new ArrayList<>();
    }
    this.config.add(configItem);
    return this;
  }

  /**
   * This option allows setting additional custom configuration per document type. If recognized
   * document has ID specified in config, processing adjusts according to designated configuration.
   *
   * @return config
   */
  @javax.annotation.Nullable
  public List<PerDocumentConfig> getConfig() {
    return config;
  }

  public void setConfig(@javax.annotation.Nullable List<PerDocumentConfig> config) {
    this.config = config;
  }

  public ProcessParams log(@javax.annotation.Nullable Boolean log) {
    this.log = log;
    return this;
  }

  /**
   * When enabled, results will contain transaction processing log. Disabled by default
   *
   * @return log
   */
  @javax.annotation.Nullable
  public Boolean getLog() {
    return log;
  }

  public void setLog(@javax.annotation.Nullable Boolean log) {
    this.log = log;
  }

  public ProcessParams logLevel(@javax.annotation.Nullable LogLevel logLevel) {
    this.logLevel = logLevel;
    return this;
  }

  /**
   * Get logLevel
   *
   * @return logLevel
   */
  @javax.annotation.Nullable
  public LogLevel getLogLevel() {
    return logLevel;
  }

  public void setLogLevel(@javax.annotation.Nullable LogLevel logLevel) {
    this.logLevel = logLevel;
  }

  public ProcessParams forceDocID(@javax.annotation.Nullable Integer forceDocID) {
    this.forceDocID = forceDocID;
    return this;
  }

  /**
   * Force use of specific template ID and skip document type identification step.
   *
   * @return forceDocID
   */
  @javax.annotation.Nullable
  public Integer getForceDocID() {
    return forceDocID;
  }

  public void setForceDocID(@javax.annotation.Nullable Integer forceDocID) {
    this.forceDocID = forceDocID;
  }

  public ProcessParams matchTextFieldMask(@javax.annotation.Nullable Boolean matchTextFieldMask) {
    this.matchTextFieldMask = matchTextFieldMask;
    return this;
  }

  /**
   * When disabled, text field OCR will be done as is and then the recognized value will be matched
   * to the field mask for validity. If enabled, we are trying to read a field value with maximum
   * efforts to match the mask and provide a correctly formatted value, making assumptions based on
   * the provided field mask in the template. Enabled by default.
   *
   * @return matchTextFieldMask
   */
  @javax.annotation.Nullable
  public Boolean getMatchTextFieldMask() {
    return matchTextFieldMask;
  }

  public void setMatchTextFieldMask(@javax.annotation.Nullable Boolean matchTextFieldMask) {
    this.matchTextFieldMask = matchTextFieldMask;
  }

  @Deprecated
  public ProcessParams fastDocDetect(@javax.annotation.Nullable Boolean fastDocDetect) {
    this.fastDocDetect = fastDocDetect;
    return this;
  }

  /**
   * When enabled, shorten the list of candidates to process during document detection in a single
   * image process mode. Reduces processing time for specific backgrounds. Enabled by default.
   *
   * @return fastDocDetect
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getFastDocDetect() {
    return fastDocDetect;
  }

  @Deprecated
  public void setFastDocDetect(@javax.annotation.Nullable Boolean fastDocDetect) {
    this.fastDocDetect = fastDocDetect;
  }

  public ProcessParams updateOCRValidityByGlare(
      @javax.annotation.Nullable Boolean updateOCRValidityByGlare) {
    this.updateOCRValidityByGlare = updateOCRValidityByGlare;
    return this;
  }

  /**
   * When enabled, fail OCR field validity, if there is a glare over the text field on the image.
   * Disabled by default.
   *
   * @return updateOCRValidityByGlare
   */
  @javax.annotation.Nullable
  public Boolean getUpdateOCRValidityByGlare() {
    return updateOCRValidityByGlare;
  }

  public void setUpdateOCRValidityByGlare(
      @javax.annotation.Nullable Boolean updateOCRValidityByGlare) {
    this.updateOCRValidityByGlare = updateOCRValidityByGlare;
  }

  public ProcessParams checkRequiredTextFields(
      @javax.annotation.Nullable Boolean checkRequiredTextFields) {
    this.checkRequiredTextFields = checkRequiredTextFields;
    return this;
  }

  /**
   * When enabled, each field in template will be checked for value presence and if the field is
   * marked as required, but has no value, it will have &#39;error&#39; in validity status. Disabled
   * by default.
   *
   * @return checkRequiredTextFields
   */
  @javax.annotation.Nullable
  public Boolean getCheckRequiredTextFields() {
    return checkRequiredTextFields;
  }

  public void setCheckRequiredTextFields(
      @javax.annotation.Nullable Boolean checkRequiredTextFields) {
    this.checkRequiredTextFields = checkRequiredTextFields;
  }

  public ProcessParams returnCroppedBarcode(
      @javax.annotation.Nullable Boolean returnCroppedBarcode) {
    this.returnCroppedBarcode = returnCroppedBarcode;
    return this;
  }

  /**
   * When enabled, returns cropped barcode images for unknown documents. Disabled by default.
   *
   * @return returnCroppedBarcode
   */
  @javax.annotation.Nullable
  public Boolean getReturnCroppedBarcode() {
    return returnCroppedBarcode;
  }

  public void setReturnCroppedBarcode(@javax.annotation.Nullable Boolean returnCroppedBarcode) {
    this.returnCroppedBarcode = returnCroppedBarcode;
  }

  public ProcessParams imageQa(@javax.annotation.Nullable ImageQA imageQa) {
    this.imageQa = imageQa;
    return this;
  }

  /**
   * Get imageQa
   *
   * @return imageQa
   */
  @javax.annotation.Nullable
  public ImageQA getImageQa() {
    return imageQa;
  }

  public void setImageQa(@javax.annotation.Nullable ImageQA imageQa) {
    this.imageQa = imageQa;
  }

  public ProcessParams strictImageQuality(@javax.annotation.Nullable Boolean strictImageQuality) {
    this.strictImageQuality = strictImageQuality;
    return this;
  }

  /**
   * When enabled, the image quality check status affects the document optical and overall status.
   * Disabled by default.
   *
   * @return strictImageQuality
   */
  @javax.annotation.Nullable
  public Boolean getStrictImageQuality() {
    return strictImageQuality;
  }

  public void setStrictImageQuality(@javax.annotation.Nullable Boolean strictImageQuality) {
    this.strictImageQuality = strictImageQuality;
  }

  @Deprecated
  public ProcessParams respectImageQuality(@javax.annotation.Nullable Boolean respectImageQuality) {
    this.respectImageQuality = respectImageQuality;
    return this;
  }

  /**
   * Deprecated. Please use strictImageQuality instead. When enabled, image quality checks status
   * affects document optical and overall status. Disabled by default.
   *
   * @return respectImageQuality
   * @deprecated
   */
  @Deprecated
  @javax.annotation.Nullable
  public Boolean getRespectImageQuality() {
    return respectImageQuality;
  }

  @Deprecated
  public void setRespectImageQuality(@javax.annotation.Nullable Boolean respectImageQuality) {
    this.respectImageQuality = respectImageQuality;
  }

  public ProcessParams forceDocFormat(@javax.annotation.Nullable DocumentFormat forceDocFormat) {
    this.forceDocFormat = forceDocFormat;
    return this;
  }

  /**
   * Get forceDocFormat
   *
   * @return forceDocFormat
   */
  @javax.annotation.Nullable
  public DocumentFormat getForceDocFormat() {
    return forceDocFormat;
  }

  public void setForceDocFormat(@javax.annotation.Nullable DocumentFormat forceDocFormat) {
    this.forceDocFormat = forceDocFormat;
  }

  public ProcessParams noGraphics(@javax.annotation.Nullable Boolean noGraphics) {
    this.noGraphics = noGraphics;
    return this;
  }

  /**
   * When enabled, no graphic fields will be cropped from document image. Disabled by default.
   *
   * @return noGraphics
   */
  @javax.annotation.Nullable
  public Boolean getNoGraphics() {
    return noGraphics;
  }

  public void setNoGraphics(@javax.annotation.Nullable Boolean noGraphics) {
    this.noGraphics = noGraphics;
  }

  public ProcessParams depersonalizeLog(@javax.annotation.Nullable Boolean depersonalizeLog) {
    this.depersonalizeLog = depersonalizeLog;
    return this;
  }

  /**
   * When enabled, all personal data will be forcibly removed from the logs. Disabled by default.
   *
   * @return depersonalizeLog
   */
  @javax.annotation.Nullable
  public Boolean getDepersonalizeLog() {
    return depersonalizeLog;
  }

  public void setDepersonalizeLog(@javax.annotation.Nullable Boolean depersonalizeLog) {
    this.depersonalizeLog = depersonalizeLog;
  }

  public ProcessParams multiDocOnImage(@javax.annotation.Nullable Boolean multiDocOnImage) {
    this.multiDocOnImage = multiDocOnImage;
    return this;
  }

  /**
   * This option allows locating and cropping multiple documents from one image if enabled. Disabled
   * by default.
   *
   * @return multiDocOnImage
   */
  @javax.annotation.Nullable
  public Boolean getMultiDocOnImage() {
    return multiDocOnImage;
  }

  public void setMultiDocOnImage(@javax.annotation.Nullable Boolean multiDocOnImage) {
    this.multiDocOnImage = multiDocOnImage;
  }

  public ProcessParams shiftExpiryDate(@javax.annotation.Nullable Integer shiftExpiryDate) {
    this.shiftExpiryDate = shiftExpiryDate;
    return this;
  }

  /**
   * This option allows shifting the date of expiry into the future or past for number of months
   * specified. This is useful, for example, in some cases when document might be still valid for
   * some period after original expiration date to prevent negative validity status for such
   * documents. Or by shifting the date to the past will set negative validity for the documents
   * that is about to expire in a specified number of months. 0 by default
   *
   * @return shiftExpiryDate
   */
  @javax.annotation.Nullable
  public Integer getShiftExpiryDate() {
    return shiftExpiryDate;
  }

  public void setShiftExpiryDate(@javax.annotation.Nullable Integer shiftExpiryDate) {
    this.shiftExpiryDate = shiftExpiryDate;
  }

  public ProcessParams minimalHolderAge(@javax.annotation.Nullable Integer minimalHolderAge) {
    this.minimalHolderAge = minimalHolderAge;
    return this;
  }

  /**
   * This options allows specifying the minimal age in years of the document holder for the document
   * to be considered valid.
   *
   * @return minimalHolderAge
   */
  @javax.annotation.Nullable
  public Integer getMinimalHolderAge() {
    return minimalHolderAge;
  }

  public void setMinimalHolderAge(@javax.annotation.Nullable Integer minimalHolderAge) {
    this.minimalHolderAge = minimalHolderAge;
  }

  public ProcessParams returnUncroppedImage(
      @javax.annotation.Nullable Boolean returnUncroppedImage) {
    this.returnUncroppedImage = returnUncroppedImage;
    return this;
  }

  /**
   * When enabled, returns input images in output. Disabled by default.
   *
   * @return returnUncroppedImage
   */
  @javax.annotation.Nullable
  public Boolean getReturnUncroppedImage() {
    return returnUncroppedImage;
  }

  public void setReturnUncroppedImage(@javax.annotation.Nullable Boolean returnUncroppedImage) {
    this.returnUncroppedImage = returnUncroppedImage;
  }

  public ProcessParams mrzFormatsFilter(
      @javax.annotation.Nullable List<MRZFormat> mrzFormatsFilter) {
    this.mrzFormatsFilter = mrzFormatsFilter;
    return this;
  }

  public ProcessParams addMrzFormatsFilterItem(MRZFormat mrzFormatsFilterItem) {
    if (this.mrzFormatsFilter == null) {
      this.mrzFormatsFilter = new ArrayList<>();
    }
    this.mrzFormatsFilter.add(mrzFormatsFilterItem);
    return this;
  }

  /**
   * This option allows limiting MRZ formats to be recognized by specifying them in array.
   *
   * @return mrzFormatsFilter
   */
  @javax.annotation.Nullable
  public List<MRZFormat> getMrzFormatsFilter() {
    return mrzFormatsFilter;
  }

  public void setMrzFormatsFilter(@javax.annotation.Nullable List<MRZFormat> mrzFormatsFilter) {
    this.mrzFormatsFilter = mrzFormatsFilter;
  }

  public ProcessParams forceReadMrzBeforeLocate(
      @javax.annotation.Nullable Boolean forceReadMrzBeforeLocate) {
    this.forceReadMrzBeforeLocate = forceReadMrzBeforeLocate;
    return this;
  }

  /**
   * When enabled, make sure that in series processing MRZ is located fully inside the result
   * document image, if present on the document. Enabling this option may add extra processing time,
   * by disabling optimizations, but allows more stability in output image quality. Disabled by
   * default.
   *
   * @return forceReadMrzBeforeLocate
   */
  @javax.annotation.Nullable
  public Boolean getForceReadMrzBeforeLocate() {
    return forceReadMrzBeforeLocate;
  }

  public void setForceReadMrzBeforeLocate(
      @javax.annotation.Nullable Boolean forceReadMrzBeforeLocate) {
    this.forceReadMrzBeforeLocate = forceReadMrzBeforeLocate;
  }

  public ProcessParams parseBarcodes(@javax.annotation.Nullable Boolean parseBarcodes) {
    this.parseBarcodes = parseBarcodes;
    return this;
  }

  /**
   * This option can be disabled to stop parsing after barcode is read. Enabled by default.
   *
   * @return parseBarcodes
   */
  @javax.annotation.Nullable
  public Boolean getParseBarcodes() {
    return parseBarcodes;
  }

  public void setParseBarcodes(@javax.annotation.Nullable Boolean parseBarcodes) {
    this.parseBarcodes = parseBarcodes;
  }

  public ProcessParams convertCase(@javax.annotation.Nullable TextPostProcessing convertCase) {
    this.convertCase = convertCase;
    return this;
  }

  /**
   * Get convertCase
   *
   * @return convertCase
   */
  @javax.annotation.Nullable
  public TextPostProcessing getConvertCase() {
    return convertCase;
  }

  public void setConvertCase(@javax.annotation.Nullable TextPostProcessing convertCase) {
    this.convertCase = convertCase;
  }

  public ProcessParams splitNames(@javax.annotation.Nullable Boolean splitNames) {
    this.splitNames = splitNames;
    return this;
  }

  /**
   * When enabled, the Surname and GivenNames fields from MRZ will be divided into ft_First_Name,
   * ft_Second_Name, ft_Third_Name, ft_Fourth_Name, ft_Last_Name fields. Disabled by default.
   *
   * @return splitNames
   */
  @javax.annotation.Nullable
  public Boolean getSplitNames() {
    return splitNames;
  }

  public void setSplitNames(@javax.annotation.Nullable Boolean splitNames) {
    this.splitNames = splitNames;
  }

  public ProcessParams disablePerforationOCR(
      @javax.annotation.Nullable Boolean disablePerforationOCR) {
    this.disablePerforationOCR = disablePerforationOCR;
    return this;
  }

  /**
   * When enabled, OCR of perforated fields in the document template will not be performed. Disabled
   * by default.
   *
   * @return disablePerforationOCR
   */
  @javax.annotation.Nullable
  public Boolean getDisablePerforationOCR() {
    return disablePerforationOCR;
  }

  public void setDisablePerforationOCR(@javax.annotation.Nullable Boolean disablePerforationOCR) {
    this.disablePerforationOCR = disablePerforationOCR;
  }

  public ProcessParams documentGroupFilter(
      @javax.annotation.Nullable List<DocumentType> documentGroupFilter) {
    this.documentGroupFilter = documentGroupFilter;
    return this;
  }

  public ProcessParams addDocumentGroupFilterItem(DocumentType documentGroupFilterItem) {
    if (this.documentGroupFilter == null) {
      this.documentGroupFilter = new ArrayList<>();
    }
    this.documentGroupFilter.add(documentGroupFilterItem);
    return this;
  }

  /**
   * List of specific eligible document types from DocumentType enum to recognize from. You may, for
   * example, specify only passports to be recognized by setting this property. Empty by default.
   *
   * @return documentGroupFilter
   */
  @javax.annotation.Nullable
  public List<DocumentType> getDocumentGroupFilter() {
    return documentGroupFilter;
  }

  public void setDocumentGroupFilter(
      @javax.annotation.Nullable List<DocumentType> documentGroupFilter) {
    this.documentGroupFilter = documentGroupFilter;
  }

  public ProcessParams processAuth(@javax.annotation.Nullable Long processAuth) {
    this.processAuth = processAuth;
    return this;
  }

  /**
   * Authenticity checks that should be performed regardless of the document type. The available
   * checks are listed in the eRPRM_Authenticity enum. Note that only supported by your license
   * checks can be added.
   *
   * @return processAuth
   */
  @javax.annotation.Nullable
  public Long getProcessAuth() {
    return processAuth;
  }

  public void setProcessAuth(@javax.annotation.Nullable Long processAuth) {
    this.processAuth = processAuth;
  }

  public ProcessParams deviceId(@javax.annotation.Nullable Integer deviceId) {
    this.deviceId = deviceId;
    return this;
  }

  /**
   * This parameter is used to specify the document reader device type from which input images were
   * captured. Default 0.
   *
   * @return deviceId
   */
  @javax.annotation.Nullable
  public Integer getDeviceId() {
    return deviceId;
  }

  public void setDeviceId(@javax.annotation.Nullable Integer deviceId) {
    this.deviceId = deviceId;
  }

  public ProcessParams deviceType(@javax.annotation.Nullable Integer deviceType) {
    this.deviceType = deviceType;
    return this;
  }

  /**
   * This parameter is used to specify the document reader device type from which input images were
   * captured. Default 0.
   *
   * @return deviceType
   */
  @javax.annotation.Nullable
  public Integer getDeviceType() {
    return deviceType;
  }

  public void setDeviceType(@javax.annotation.Nullable Integer deviceType) {
    this.deviceType = deviceType;
  }

  public ProcessParams deviceTypeHex(@javax.annotation.Nullable String deviceTypeHex) {
    this.deviceTypeHex = deviceTypeHex;
    return this;
  }

  /**
   * This parameter is used to specify the document reader device type from which input images were
   * captured
   *
   * @return deviceTypeHex
   */
  @javax.annotation.Nullable
  public String getDeviceTypeHex() {
    return deviceTypeHex;
  }

  public void setDeviceTypeHex(@javax.annotation.Nullable String deviceTypeHex) {
    this.deviceTypeHex = deviceTypeHex;
  }

  public ProcessParams ignoreDeviceIdFromImage(
      @javax.annotation.Nullable Boolean ignoreDeviceIdFromImage) {
    this.ignoreDeviceIdFromImage = ignoreDeviceIdFromImage;
    return this;
  }

  /**
   * This parameter is used to tell the processing engine to ignore any parameters saved in the
   * image when scanned from the document reader device. Default false
   *
   * @return ignoreDeviceIdFromImage
   */
  @javax.annotation.Nullable
  public Boolean getIgnoreDeviceIdFromImage() {
    return ignoreDeviceIdFromImage;
  }

  public void setIgnoreDeviceIdFromImage(
      @javax.annotation.Nullable Boolean ignoreDeviceIdFromImage) {
    this.ignoreDeviceIdFromImage = ignoreDeviceIdFromImage;
  }

  public ProcessParams documentIdList(@javax.annotation.Nullable List<Integer> documentIdList) {
    this.documentIdList = documentIdList;
    return this;
  }

  public ProcessParams addDocumentIdListItem(Integer documentIdListItem) {
    if (this.documentIdList == null) {
      this.documentIdList = new ArrayList<>();
    }
    this.documentIdList.add(documentIdListItem);
    return this;
  }

  /**
   * List of the document ID&#39;s to process. All documents will be processed, if empty.
   *
   * @return documentIdList
   */
  @javax.annotation.Nullable
  public List<Integer> getDocumentIdList() {
    return documentIdList;
  }

  public void setDocumentIdList(@javax.annotation.Nullable List<Integer> documentIdList) {
    this.documentIdList = documentIdList;
  }

  public ProcessParams rfid(@javax.annotation.Nullable ProcessParamsRfid rfid) {
    this.rfid = rfid;
    return this;
  }

  /**
   * Get rfid
   *
   * @return rfid
   */
  @javax.annotation.Nullable
  public ProcessParamsRfid getRfid() {
    return rfid;
  }

  public void setRfid(@javax.annotation.Nullable ProcessParamsRfid rfid) {
    this.rfid = rfid;
  }

  public ProcessParams checkAuth(@javax.annotation.Nullable Boolean checkAuth) {
    this.checkAuth = checkAuth;
    return this;
  }

  /**
   * This parameter is used to enable authenticity checks
   *
   * @return checkAuth
   */
  @javax.annotation.Nullable
  public Boolean getCheckAuth() {
    return checkAuth;
  }

  public void setCheckAuth(@javax.annotation.Nullable Boolean checkAuth) {
    this.checkAuth = checkAuth;
  }

  public ProcessParams authParams(@javax.annotation.Nullable AuthParams authParams) {
    this.authParams = authParams;
    return this;
  }

  /**
   * Get authParams
   *
   * @return authParams
   */
  @javax.annotation.Nullable
  public AuthParams getAuthParams() {
    return authParams;
  }

  public void setAuthParams(@javax.annotation.Nullable AuthParams authParams) {
    this.authParams = authParams;
  }

  public ProcessParams mrzDetectMode(@javax.annotation.Nullable MrzDetectModeEnum mrzDetectMode) {
    this.mrzDetectMode = mrzDetectMode;
    return this;
  }

  /**
   * Get mrzDetectMode
   *
   * @return mrzDetectMode
   */
  @javax.annotation.Nullable
  public MrzDetectModeEnum getMrzDetectMode() {
    return mrzDetectMode;
  }

  public void setMrzDetectMode(@javax.annotation.Nullable MrzDetectModeEnum mrzDetectMode) {
    this.mrzDetectMode = mrzDetectMode;
  }

  public ProcessParams generateNumericCodes(
      @javax.annotation.Nullable Boolean generateNumericCodes) {
    this.generateNumericCodes = generateNumericCodes;
    return this;
  }

  /**
   * This parameter is used to generate numeric representation for issuing state and nationality
   * codes
   *
   * @return generateNumericCodes
   */
  @javax.annotation.Nullable
  public Boolean getGenerateNumericCodes() {
    return generateNumericCodes;
  }

  public void setGenerateNumericCodes(@javax.annotation.Nullable Boolean generateNumericCodes) {
    this.generateNumericCodes = generateNumericCodes;
  }

  public ProcessParams strictBarcodeDigitalSignatureCheck(
      @javax.annotation.Nullable Boolean strictBarcodeDigitalSignatureCheck) {
    this.strictBarcodeDigitalSignatureCheck = strictBarcodeDigitalSignatureCheck;
    return this;
  }

  /**
   * This parameter if enabled will require all necessary certificates to verify digital signature
   * in barcode data to be present in order for the Barcode format check to succeed.
   *
   * @return strictBarcodeDigitalSignatureCheck
   */
  @javax.annotation.Nullable
  public Boolean getStrictBarcodeDigitalSignatureCheck() {
    return strictBarcodeDigitalSignatureCheck;
  }

  public void setStrictBarcodeDigitalSignatureCheck(
      @javax.annotation.Nullable Boolean strictBarcodeDigitalSignatureCheck) {
    this.strictBarcodeDigitalSignatureCheck = strictBarcodeDigitalSignatureCheck;
  }

  public ProcessParams selectLongestNames(@javax.annotation.Nullable Boolean selectLongestNames) {
    this.selectLongestNames = selectLongestNames;
    return this;
  }

  /**
   * Select the longest value from the different value sources and write it to the value field if
   * comparison is done successfully. The parameter applies this logic to the personal names, such
   * as given name, surname, surname and given name, middle name and etc.
   *
   * @return selectLongestNames
   */
  @javax.annotation.Nullable
  public Boolean getSelectLongestNames() {
    return selectLongestNames;
  }

  public void setSelectLongestNames(@javax.annotation.Nullable Boolean selectLongestNames) {
    this.selectLongestNames = selectLongestNames;
  }

  public ProcessParams doBarcodes(@javax.annotation.Nullable List<InputBarcodeType> doBarcodes) {
    this.doBarcodes = doBarcodes;
    return this;
  }

  public ProcessParams addDoBarcodesItem(InputBarcodeType doBarcodesItem) {
    if (this.doBarcodes == null) {
      this.doBarcodes = new ArrayList<>();
    }
    this.doBarcodes.add(doBarcodesItem);
    return this;
  }

  /**
   * Set the types of barcodes to process.
   *
   * @return doBarcodes
   */
  @javax.annotation.Nullable
  public List<InputBarcodeType> getDoBarcodes() {
    return doBarcodes;
  }

  public void setDoBarcodes(@javax.annotation.Nullable List<InputBarcodeType> doBarcodes) {
    this.doBarcodes = doBarcodes;
  }

  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProcessParams processParams = (ProcessParams) o;
    return Objects.equals(this.generateDTCVC, processParams.generateDTCVC)
        && Objects.equals(this.lcidFilter, processParams.lcidFilter)
        && Objects.equals(this.checkLiveness, processParams.checkLiveness)
        && Objects.equals(this.lcidIgnoreFilter, processParams.lcidIgnoreFilter)
        && Objects.equals(this.oneShotIdentification, processParams.oneShotIdentification)
        && Objects.equals(this.useFaceApi, processParams.useFaceApi)
        && Objects.equals(this.faceApi, processParams.faceApi)
        && Objects.equals(this.doDetectCan, processParams.doDetectCan)
        && Objects.equals(this.imageOutputMaxHeight, processParams.imageOutputMaxHeight)
        && Objects.equals(this.imageOutputMaxWidth, processParams.imageOutputMaxWidth)
        && Objects.equals(this.scenario, processParams.scenario)
        && Objects.equals(this.resultTypeOutput, processParams.resultTypeOutput)
        && Objects.equals(this.doublePageSpread, processParams.doublePageSpread)
        && Objects.equals(
            this.generateDoublePageSpreadImage, processParams.generateDoublePageSpreadImage)
        && Objects.equals(this.fieldTypesFilter, processParams.fieldTypesFilter)
        && Objects.equals(this.dateFormat, processParams.dateFormat)
        && Objects.equals(this.measureSystem, processParams.measureSystem)
        && Objects.equals(this.imageDpiOutMax, processParams.imageDpiOutMax)
        && Objects.equals(this.alreadyCropped, processParams.alreadyCropped)
        && Objects.equals(this.customParams, processParams.customParams)
        && Objects.equals(this.config, processParams.config)
        && Objects.equals(this.log, processParams.log)
        && Objects.equals(this.logLevel, processParams.logLevel)
        && Objects.equals(this.forceDocID, processParams.forceDocID)
        && Objects.equals(this.matchTextFieldMask, processParams.matchTextFieldMask)
        && Objects.equals(this.fastDocDetect, processParams.fastDocDetect)
        && Objects.equals(this.updateOCRValidityByGlare, processParams.updateOCRValidityByGlare)
        && Objects.equals(this.checkRequiredTextFields, processParams.checkRequiredTextFields)
        && Objects.equals(this.returnCroppedBarcode, processParams.returnCroppedBarcode)
        && Objects.equals(this.imageQa, processParams.imageQa)
        && Objects.equals(this.strictImageQuality, processParams.strictImageQuality)
        && Objects.equals(this.respectImageQuality, processParams.respectImageQuality)
        && Objects.equals(this.forceDocFormat, processParams.forceDocFormat)
        && Objects.equals(this.noGraphics, processParams.noGraphics)
        && Objects.equals(this.depersonalizeLog, processParams.depersonalizeLog)
        && Objects.equals(this.multiDocOnImage, processParams.multiDocOnImage)
        && Objects.equals(this.shiftExpiryDate, processParams.shiftExpiryDate)
        && Objects.equals(this.minimalHolderAge, processParams.minimalHolderAge)
        && Objects.equals(this.returnUncroppedImage, processParams.returnUncroppedImage)
        && Objects.equals(this.mrzFormatsFilter, processParams.mrzFormatsFilter)
        && Objects.equals(this.forceReadMrzBeforeLocate, processParams.forceReadMrzBeforeLocate)
        && Objects.equals(this.parseBarcodes, processParams.parseBarcodes)
        && Objects.equals(this.convertCase, processParams.convertCase)
        && Objects.equals(this.splitNames, processParams.splitNames)
        && Objects.equals(this.disablePerforationOCR, processParams.disablePerforationOCR)
        && Objects.equals(this.documentGroupFilter, processParams.documentGroupFilter)
        && Objects.equals(this.processAuth, processParams.processAuth)
        && Objects.equals(this.deviceId, processParams.deviceId)
        && Objects.equals(this.deviceType, processParams.deviceType)
        && Objects.equals(this.deviceTypeHex, processParams.deviceTypeHex)
        && Objects.equals(this.ignoreDeviceIdFromImage, processParams.ignoreDeviceIdFromImage)
        && Objects.equals(this.documentIdList, processParams.documentIdList)
        && Objects.equals(this.rfid, processParams.rfid)
        && Objects.equals(this.checkAuth, processParams.checkAuth)
        && Objects.equals(this.authParams, processParams.authParams)
        && Objects.equals(this.mrzDetectMode, processParams.mrzDetectMode)
        && Objects.equals(this.generateNumericCodes, processParams.generateNumericCodes)
        && Objects.equals(
            this.strictBarcodeDigitalSignatureCheck,
            processParams.strictBarcodeDigitalSignatureCheck)
        && Objects.equals(this.selectLongestNames, processParams.selectLongestNames)
        && Objects.equals(this.doBarcodes, processParams.doBarcodes);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        generateDTCVC,
        lcidFilter,
        checkLiveness,
        lcidIgnoreFilter,
        oneShotIdentification,
        useFaceApi,
        faceApi,
        doDetectCan,
        imageOutputMaxHeight,
        imageOutputMaxWidth,
        scenario,
        resultTypeOutput,
        doublePageSpread,
        generateDoublePageSpreadImage,
        fieldTypesFilter,
        dateFormat,
        measureSystem,
        imageDpiOutMax,
        alreadyCropped,
        customParams,
        config,
        log,
        logLevel,
        forceDocID,
        matchTextFieldMask,
        fastDocDetect,
        updateOCRValidityByGlare,
        checkRequiredTextFields,
        returnCroppedBarcode,
        imageQa,
        strictImageQuality,
        respectImageQuality,
        forceDocFormat,
        noGraphics,
        depersonalizeLog,
        multiDocOnImage,
        shiftExpiryDate,
        minimalHolderAge,
        returnUncroppedImage,
        mrzFormatsFilter,
        forceReadMrzBeforeLocate,
        parseBarcodes,
        convertCase,
        splitNames,
        disablePerforationOCR,
        documentGroupFilter,
        processAuth,
        deviceId,
        deviceType,
        deviceTypeHex,
        ignoreDeviceIdFromImage,
        documentIdList,
        rfid,
        checkAuth,
        authParams,
        mrzDetectMode,
        generateNumericCodes,
        strictBarcodeDigitalSignatureCheck,
        selectLongestNames,
        doBarcodes);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProcessParams {\n");
    sb.append("    generateDTCVC: ").append(toIndentedString(generateDTCVC)).append("\n");
    sb.append("    lcidFilter: ").append(toIndentedString(lcidFilter)).append("\n");
    sb.append("    checkLiveness: ").append(toIndentedString(checkLiveness)).append("\n");
    sb.append("    lcidIgnoreFilter: ").append(toIndentedString(lcidIgnoreFilter)).append("\n");
    sb.append("    oneShotIdentification: ")
        .append(toIndentedString(oneShotIdentification))
        .append("\n");
    sb.append("    useFaceApi: ").append(toIndentedString(useFaceApi)).append("\n");
    sb.append("    faceApi: ").append(toIndentedString(faceApi)).append("\n");
    sb.append("    doDetectCan: ").append(toIndentedString(doDetectCan)).append("\n");
    sb.append("    imageOutputMaxHeight: ")
        .append(toIndentedString(imageOutputMaxHeight))
        .append("\n");
    sb.append("    imageOutputMaxWidth: ")
        .append(toIndentedString(imageOutputMaxWidth))
        .append("\n");
    sb.append("    scenario: ").append(toIndentedString(scenario)).append("\n");
    sb.append("    resultTypeOutput: ").append(toIndentedString(resultTypeOutput)).append("\n");
    sb.append("    doublePageSpread: ").append(toIndentedString(doublePageSpread)).append("\n");
    sb.append("    generateDoublePageSpreadImage: ")
        .append(toIndentedString(generateDoublePageSpreadImage))
        .append("\n");
    sb.append("    fieldTypesFilter: ").append(toIndentedString(fieldTypesFilter)).append("\n");
    sb.append("    dateFormat: ").append(toIndentedString(dateFormat)).append("\n");
    sb.append("    measureSystem: ").append(toIndentedString(measureSystem)).append("\n");
    sb.append("    imageDpiOutMax: ").append(toIndentedString(imageDpiOutMax)).append("\n");
    sb.append("    alreadyCropped: ").append(toIndentedString(alreadyCropped)).append("\n");
    sb.append("    customParams: ").append(toIndentedString(customParams)).append("\n");
    sb.append("    config: ").append(toIndentedString(config)).append("\n");
    sb.append("    log: ").append(toIndentedString(log)).append("\n");
    sb.append("    logLevel: ").append(toIndentedString(logLevel)).append("\n");
    sb.append("    forceDocID: ").append(toIndentedString(forceDocID)).append("\n");
    sb.append("    matchTextFieldMask: ").append(toIndentedString(matchTextFieldMask)).append("\n");
    sb.append("    fastDocDetect: ").append(toIndentedString(fastDocDetect)).append("\n");
    sb.append("    updateOCRValidityByGlare: ")
        .append(toIndentedString(updateOCRValidityByGlare))
        .append("\n");
    sb.append("    checkRequiredTextFields: ")
        .append(toIndentedString(checkRequiredTextFields))
        .append("\n");
    sb.append("    returnCroppedBarcode: ")
        .append(toIndentedString(returnCroppedBarcode))
        .append("\n");
    sb.append("    imageQa: ").append(toIndentedString(imageQa)).append("\n");
    sb.append("    strictImageQuality: ").append(toIndentedString(strictImageQuality)).append("\n");
    sb.append("    respectImageQuality: ")
        .append(toIndentedString(respectImageQuality))
        .append("\n");
    sb.append("    forceDocFormat: ").append(toIndentedString(forceDocFormat)).append("\n");
    sb.append("    noGraphics: ").append(toIndentedString(noGraphics)).append("\n");
    sb.append("    depersonalizeLog: ").append(toIndentedString(depersonalizeLog)).append("\n");
    sb.append("    multiDocOnImage: ").append(toIndentedString(multiDocOnImage)).append("\n");
    sb.append("    shiftExpiryDate: ").append(toIndentedString(shiftExpiryDate)).append("\n");
    sb.append("    minimalHolderAge: ").append(toIndentedString(minimalHolderAge)).append("\n");
    sb.append("    returnUncroppedImage: ")
        .append(toIndentedString(returnUncroppedImage))
        .append("\n");
    sb.append("    mrzFormatsFilter: ").append(toIndentedString(mrzFormatsFilter)).append("\n");
    sb.append("    forceReadMrzBeforeLocate: ")
        .append(toIndentedString(forceReadMrzBeforeLocate))
        .append("\n");
    sb.append("    parseBarcodes: ").append(toIndentedString(parseBarcodes)).append("\n");
    sb.append("    convertCase: ").append(toIndentedString(convertCase)).append("\n");
    sb.append("    splitNames: ").append(toIndentedString(splitNames)).append("\n");
    sb.append("    disablePerforationOCR: ")
        .append(toIndentedString(disablePerforationOCR))
        .append("\n");
    sb.append("    documentGroupFilter: ")
        .append(toIndentedString(documentGroupFilter))
        .append("\n");
    sb.append("    processAuth: ").append(toIndentedString(processAuth)).append("\n");
    sb.append("    deviceId: ").append(toIndentedString(deviceId)).append("\n");
    sb.append("    deviceType: ").append(toIndentedString(deviceType)).append("\n");
    sb.append("    deviceTypeHex: ").append(toIndentedString(deviceTypeHex)).append("\n");
    sb.append("    ignoreDeviceIdFromImage: ")
        .append(toIndentedString(ignoreDeviceIdFromImage))
        .append("\n");
    sb.append("    documentIdList: ").append(toIndentedString(documentIdList)).append("\n");
    sb.append("    rfid: ").append(toIndentedString(rfid)).append("\n");
    sb.append("    checkAuth: ").append(toIndentedString(checkAuth)).append("\n");
    sb.append("    authParams: ").append(toIndentedString(authParams)).append("\n");
    sb.append("    mrzDetectMode: ").append(toIndentedString(mrzDetectMode)).append("\n");
    sb.append("    generateNumericCodes: ")
        .append(toIndentedString(generateNumericCodes))
        .append("\n");
    sb.append("    strictBarcodeDigitalSignatureCheck: ")
        .append(toIndentedString(strictBarcodeDigitalSignatureCheck))
        .append("\n");
    sb.append("    selectLongestNames: ").append(toIndentedString(selectLongestNames)).append("\n");
    sb.append("    doBarcodes: ").append(toIndentedString(doBarcodes)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  public static HashSet<String> openapiFields;
  public static HashSet<String> openapiRequiredFields;

  static {
    // a set of all properties/fields (JSON key names)
    openapiFields = new HashSet<String>();
    openapiFields.add("generateDTCVC");
    openapiFields.add("lcidFilter");
    openapiFields.add("checkLiveness");
    openapiFields.add("lcidIgnoreFilter");
    openapiFields.add("oneShotIdentification");
    openapiFields.add("useFaceApi");
    openapiFields.add("faceApi");
    openapiFields.add("doDetectCan");
    openapiFields.add("imageOutputMaxHeight");
    openapiFields.add("imageOutputMaxWidth");
    openapiFields.add("scenario");
    openapiFields.add("resultTypeOutput");
    openapiFields.add("doublePageSpread");
    openapiFields.add("generateDoublePageSpreadImage");
    openapiFields.add("fieldTypesFilter");
    openapiFields.add("dateFormat");
    openapiFields.add("measureSystem");
    openapiFields.add("imageDpiOutMax");
    openapiFields.add("alreadyCropped");
    openapiFields.add("customParams");
    openapiFields.add("config");
    openapiFields.add("log");
    openapiFields.add("logLevel");
    openapiFields.add("forceDocID");
    openapiFields.add("matchTextFieldMask");
    openapiFields.add("fastDocDetect");
    openapiFields.add("updateOCRValidityByGlare");
    openapiFields.add("checkRequiredTextFields");
    openapiFields.add("returnCroppedBarcode");
    openapiFields.add("imageQa");
    openapiFields.add("strictImageQuality");
    openapiFields.add("respectImageQuality");
    openapiFields.add("forceDocFormat");
    openapiFields.add("noGraphics");
    openapiFields.add("depersonalizeLog");
    openapiFields.add("multiDocOnImage");
    openapiFields.add("shiftExpiryDate");
    openapiFields.add("minimalHolderAge");
    openapiFields.add("returnUncroppedImage");
    openapiFields.add("mrzFormatsFilter");
    openapiFields.add("forceReadMrzBeforeLocate");
    openapiFields.add("parseBarcodes");
    openapiFields.add("convertCase");
    openapiFields.add("splitNames");
    openapiFields.add("disablePerforationOCR");
    openapiFields.add("documentGroupFilter");
    openapiFields.add("processAuth");
    openapiFields.add("deviceId");
    openapiFields.add("deviceType");
    openapiFields.add("deviceTypeHex");
    openapiFields.add("ignoreDeviceIdFromImage");
    openapiFields.add("documentIdList");
    openapiFields.add("rfid");
    openapiFields.add("checkAuth");
    openapiFields.add("authParams");
    openapiFields.add("mrzDetectMode");
    openapiFields.add("generateNumericCodes");
    openapiFields.add("strictBarcodeDigitalSignatureCheck");
    openapiFields.add("selectLongestNames");
    openapiFields.add("doBarcodes");

    // a set of required properties/fields (JSON key names)
    openapiRequiredFields = new HashSet<String>();
    openapiRequiredFields.add("scenario");
  }

  /**
   * Validates the JSON Element and throws an exception if issues found
   *
   * @param jsonElement JSON Element
   * @throws IOException if the JSON Element is invalid with respect to ProcessParams
   */
  public static void validateJsonElement(JsonElement jsonElement) throws IOException {
    if (jsonElement == null) {
      if (!ProcessParams.openapiRequiredFields
          .isEmpty()) { // has required fields but JSON element is null
        throw new IllegalArgumentException(
            String.format(
                "The required field(s) %s in ProcessParams is not found in the empty JSON string",
                ProcessParams.openapiRequiredFields.toString()));
      }
    }

    Set<Map.Entry<String, JsonElement>> entries = jsonElement.getAsJsonObject().entrySet();
    // check to see if the JSON string contains additional fields
    for (Map.Entry<String, JsonElement> entry : entries) {
      if (!ProcessParams.openapiFields.contains(entry.getKey())) {
        throw new IllegalArgumentException(
            String.format(
                "The field `%s` in the JSON string is not defined in the `ProcessParams` properties. JSON: %s",
                entry.getKey(), jsonElement.toString()));
      }
    }

    // check to make sure all required properties/fields are present in the JSON string
    for (String requiredField : ProcessParams.openapiRequiredFields) {
      if (jsonElement.getAsJsonObject().get(requiredField) == null) {
        throw new IllegalArgumentException(
            String.format(
                "The required field `%s` is not found in the JSON string: %s",
                requiredField, jsonElement.toString()));
      }
    }
    JsonObject jsonObj = jsonElement.getAsJsonObject();
    // ensure the optional json data is an array if present
    if (jsonObj.get("lcidFilter") != null
        && !jsonObj.get("lcidFilter").isJsonNull()
        && !jsonObj.get("lcidFilter").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `lcidFilter` to be an array in the JSON string but got `%s`",
              jsonObj.get("lcidFilter").toString()));
    }
    // ensure the optional json data is an array if present
    if (jsonObj.get("lcidIgnoreFilter") != null
        && !jsonObj.get("lcidIgnoreFilter").isJsonNull()
        && !jsonObj.get("lcidIgnoreFilter").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `lcidIgnoreFilter` to be an array in the JSON string but got `%s`",
              jsonObj.get("lcidIgnoreFilter").toString()));
    }
    // validate the optional field `faceApi`
    if (jsonObj.get("faceApi") != null && !jsonObj.get("faceApi").isJsonNull()) {
      FaceApi.validateJsonElement(jsonObj.get("faceApi"));
    }
    // validate the required field `scenario`
    Scenario.validateJsonElement(jsonObj.get("scenario"));
    // ensure the optional json data is an array if present
    if (jsonObj.get("resultTypeOutput") != null
        && !jsonObj.get("resultTypeOutput").isJsonNull()
        && !jsonObj.get("resultTypeOutput").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `resultTypeOutput` to be an array in the JSON string but got `%s`",
              jsonObj.get("resultTypeOutput").toString()));
    }
    // ensure the optional json data is an array if present
    if (jsonObj.get("fieldTypesFilter") != null
        && !jsonObj.get("fieldTypesFilter").isJsonNull()
        && !jsonObj.get("fieldTypesFilter").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `fieldTypesFilter` to be an array in the JSON string but got `%s`",
              jsonObj.get("fieldTypesFilter").toString()));
    }
    if ((jsonObj.get("dateFormat") != null && !jsonObj.get("dateFormat").isJsonNull())
        && !jsonObj.get("dateFormat").isJsonPrimitive()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `dateFormat` to be a primitive type in the JSON string but got `%s`",
              jsonObj.get("dateFormat").toString()));
    }
    // validate the optional field `measureSystem`
    if (jsonObj.get("measureSystem") != null && !jsonObj.get("measureSystem").isJsonNull()) {
      MeasureSystem.validateJsonElement(jsonObj.get("measureSystem"));
    }
    if (jsonObj.get("config") != null && !jsonObj.get("config").isJsonNull()) {
      JsonArray jsonArrayconfig = jsonObj.getAsJsonArray("config");
      if (jsonArrayconfig != null) {
        // ensure the json data is an array
        if (!jsonObj.get("config").isJsonArray()) {
          throw new IllegalArgumentException(
              String.format(
                  "Expected the field `config` to be an array in the JSON string but got `%s`",
                  jsonObj.get("config").toString()));
        }

        // validate the optional field `config` (array)
        for (int i = 0; i < jsonArrayconfig.size(); i++) {
          PerDocumentConfig.validateJsonElement(jsonArrayconfig.get(i));
        }
        ;
      }
    }
    // validate the optional field `logLevel`
    if (jsonObj.get("logLevel") != null && !jsonObj.get("logLevel").isJsonNull()) {
      LogLevel.validateJsonElement(jsonObj.get("logLevel"));
    }
    // validate the optional field `imageQa`
    if (jsonObj.get("imageQa") != null && !jsonObj.get("imageQa").isJsonNull()) {
      ImageQA.validateJsonElement(jsonObj.get("imageQa"));
    }
    // validate the optional field `forceDocFormat`
    if (jsonObj.get("forceDocFormat") != null && !jsonObj.get("forceDocFormat").isJsonNull()) {
      DocumentFormat.validateJsonElement(jsonObj.get("forceDocFormat"));
    }
    // ensure the optional json data is an array if present
    if (jsonObj.get("mrzFormatsFilter") != null
        && !jsonObj.get("mrzFormatsFilter").isJsonNull()
        && !jsonObj.get("mrzFormatsFilter").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `mrzFormatsFilter` to be an array in the JSON string but got `%s`",
              jsonObj.get("mrzFormatsFilter").toString()));
    }
    // validate the optional field `convertCase`
    if (jsonObj.get("convertCase") != null && !jsonObj.get("convertCase").isJsonNull()) {
      TextPostProcessing.validateJsonElement(jsonObj.get("convertCase"));
    }
    // ensure the optional json data is an array if present
    if (jsonObj.get("documentGroupFilter") != null
        && !jsonObj.get("documentGroupFilter").isJsonNull()
        && !jsonObj.get("documentGroupFilter").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `documentGroupFilter` to be an array in the JSON string but got `%s`",
              jsonObj.get("documentGroupFilter").toString()));
    }
    if ((jsonObj.get("deviceTypeHex") != null && !jsonObj.get("deviceTypeHex").isJsonNull())
        && !jsonObj.get("deviceTypeHex").isJsonPrimitive()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `deviceTypeHex` to be a primitive type in the JSON string but got `%s`",
              jsonObj.get("deviceTypeHex").toString()));
    }
    // ensure the optional json data is an array if present
    if (jsonObj.get("documentIdList") != null
        && !jsonObj.get("documentIdList").isJsonNull()
        && !jsonObj.get("documentIdList").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `documentIdList` to be an array in the JSON string but got `%s`",
              jsonObj.get("documentIdList").toString()));
    }
    // validate the optional field `rfid`
    if (jsonObj.get("rfid") != null && !jsonObj.get("rfid").isJsonNull()) {
      ProcessParamsRfid.validateJsonElement(jsonObj.get("rfid"));
    }
    // validate the optional field `authParams`
    if (jsonObj.get("authParams") != null && !jsonObj.get("authParams").isJsonNull()) {
      AuthParams.validateJsonElement(jsonObj.get("authParams"));
    }
    // validate the optional field `mrzDetectMode`
    if (jsonObj.get("mrzDetectMode") != null && !jsonObj.get("mrzDetectMode").isJsonNull()) {
      MrzDetectModeEnum.validateJsonElement(jsonObj.get("mrzDetectMode"));
    }
    // ensure the optional json data is an array if present
    if (jsonObj.get("doBarcodes") != null
        && !jsonObj.get("doBarcodes").isJsonNull()
        && !jsonObj.get("doBarcodes").isJsonArray()) {
      throw new IllegalArgumentException(
          String.format(
              "Expected the field `doBarcodes` to be an array in the JSON string but got `%s`",
              jsonObj.get("doBarcodes").toString()));
    }
  }

  public static class CustomTypeAdapterFactory implements TypeAdapterFactory {
    @SuppressWarnings("unchecked")
    @Override
    public <T> TypeAdapter<T> create(Gson gson, TypeToken<T> type) {
      if (!ProcessParams.class.isAssignableFrom(type.getRawType())) {
        return null; // this class only serializes 'ProcessParams' and its subtypes
      }
      final TypeAdapter<JsonElement> elementAdapter = gson.getAdapter(JsonElement.class);
      final TypeAdapter<ProcessParams> thisAdapter =
          gson.getDelegateAdapter(this, TypeToken.get(ProcessParams.class));

      return (TypeAdapter<T>)
          new TypeAdapter<ProcessParams>() {
            @Override
            public void write(JsonWriter out, ProcessParams value) throws IOException {
              JsonObject obj = thisAdapter.toJsonTree(value).getAsJsonObject();
              elementAdapter.write(out, obj);
            }

            @Override
            public ProcessParams read(JsonReader in) throws IOException {
              JsonElement jsonElement = elementAdapter.read(in);
              validateJsonElement(jsonElement);
              return thisAdapter.fromJsonTree(jsonElement);
            }
          }.nullSafe();
    }
  }

  /**
   * Create an instance of ProcessParams given an JSON string
   *
   * @param jsonString JSON string
   * @return An instance of ProcessParams
   * @throws IOException if the JSON string is invalid with respect to ProcessParams
   */
  public static ProcessParams fromJson(String jsonString) throws IOException {
    return JSON.getGson().fromJson(jsonString, ProcessParams.class);
  }

  /**
   * Convert an instance of ProcessParams to an JSON string
   *
   * @return JSON string
   */
  public String toJson() {
    return JSON.getGson().toJson(this);
  }
}
