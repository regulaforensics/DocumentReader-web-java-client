/*
 * Regula Document Reader Web API
 * Documents recognition as easy as reading two bytes.  # Clients: * [JavaScript](https://github.com/regulaforensics/DocumentReader-web-js-client) client for the browser and node.js based on axios * [Java](https://github.com/regulaforensics/DocumentReader-web-java-client) client compatible with jvm and android * [Python](https://github.com/regulaforensics/DocumentReader-web-python-client) 3.5+ client * [C#](https://github.com/regulaforensics/DocumentReader-web-csharp-client) client for .NET & .NET Core
 *
 * The version of the OpenAPI document: 5.5.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.regula.documentreader.webclient.model;

import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/** ProcessParams */
public class ProcessParams {
  public static final String SERIALIZED_NAME_SCENARIO = "scenario";

  @SerializedName(SERIALIZED_NAME_SCENARIO)
  private String scenario;

  public static final String SERIALIZED_NAME_RESULT_TYPE_OUTPUT = "resultTypeOutput";

  @SerializedName(SERIALIZED_NAME_RESULT_TYPE_OUTPUT)
  private List<Integer> resultTypeOutput = null;

  public static final String SERIALIZED_NAME_DOUBLE_PAGE_SPREAD = "doublePageSpread";

  @SerializedName(SERIALIZED_NAME_DOUBLE_PAGE_SPREAD)
  private Boolean doublePageSpread;

  public static final String SERIALIZED_NAME_FIELD_TYPES_FILTER = "fieldTypesFilter";

  @SerializedName(SERIALIZED_NAME_FIELD_TYPES_FILTER)
  private List<Integer> fieldTypesFilter = null;

  public static final String SERIALIZED_NAME_DATE_FORMAT = "dateFormat";

  @SerializedName(SERIALIZED_NAME_DATE_FORMAT)
  private String dateFormat;

  public static final String SERIALIZED_NAME_IMAGE_DPI_OUT_MAX = "imageDpiOutMax";

  @SerializedName(SERIALIZED_NAME_IMAGE_DPI_OUT_MAX)
  private Integer imageDpiOutMax;

  public static final String SERIALIZED_NAME_ALREADY_CROPPED = "alreadyCropped";

  @SerializedName(SERIALIZED_NAME_ALREADY_CROPPED)
  private Boolean alreadyCropped;

  public static final String SERIALIZED_NAME_CUSTOM_PARAMS = "customParams";

  @SerializedName(SERIALIZED_NAME_CUSTOM_PARAMS)
  private Map<String, Object> customParams = null;

  public static final String SERIALIZED_NAME_LOG = "log";

  @SerializedName(SERIALIZED_NAME_LOG)
  private Boolean log;

  public static final String SERIALIZED_NAME_FORCE_DOC_I_D = "forceDocID";

  @SerializedName(SERIALIZED_NAME_FORCE_DOC_I_D)
  private Integer forceDocID;

  public static final String SERIALIZED_NAME_MATCH_TEXT_FIELD_MASK = "matchTextFieldMask";

  @SerializedName(SERIALIZED_NAME_MATCH_TEXT_FIELD_MASK)
  private Boolean matchTextFieldMask = true;

  public static final String SERIALIZED_NAME_FAST_DOC_DETECT = "fastDocDetect";

  @SerializedName(SERIALIZED_NAME_FAST_DOC_DETECT)
  private Boolean fastDocDetect = true;

  public static final String SERIALIZED_NAME_UPDATE_O_C_R_VALIDITY_BY_GLARE =
      "updateOCRValidityByGlare";

  @SerializedName(SERIALIZED_NAME_UPDATE_O_C_R_VALIDITY_BY_GLARE)
  private Boolean updateOCRValidityByGlare = false;

  public static final String SERIALIZED_NAME_GENERATE_DOUBLE_PAGE_SPREAD_IMAGE =
      "generateDoublePageSpreadImage";

  @SerializedName(SERIALIZED_NAME_GENERATE_DOUBLE_PAGE_SPREAD_IMAGE)
  private Boolean generateDoublePageSpreadImage;

  public static final String SERIALIZED_NAME_CHECK_REQUIRED_TEXT_FIELDS = "checkRequiredTextFields";

  @SerializedName(SERIALIZED_NAME_CHECK_REQUIRED_TEXT_FIELDS)
  private Boolean checkRequiredTextFields = false;

  public static final String SERIALIZED_NAME_IMAGE_Q_A = "imageQA";

  @SerializedName(SERIALIZED_NAME_IMAGE_Q_A)
  private ImageQA imageQA;

  public ProcessParams withScenario(String scenario) {
    this.scenario = scenario;
    return this;
  }

  /**
   * Get scenario
   *
   * @return scenario
   */
  public String getScenario() {
    return scenario;
  }

  public void setScenario(String scenario) {
    this.scenario = scenario;
  }

  public ProcessParams withResultTypeOutput(List<Integer> resultTypeOutput) {
    this.resultTypeOutput = resultTypeOutput;
    return this;
  }

  public ProcessParams addResultTypeOutputItem(Integer resultTypeOutputItem) {
    if (this.resultTypeOutput == null) {
      this.resultTypeOutput = new ArrayList<Integer>();
    }
    this.resultTypeOutput.add(resultTypeOutputItem);
    return this;
  }

  /**
   * Types of results to return in response. See &#39;Result&#39; enum for available options
   *
   * @return resultTypeOutput
   */
  @javax.annotation.Nullable
  public List<Integer> getResultTypeOutput() {
    return resultTypeOutput;
  }

  public void setResultTypeOutput(List<Integer> resultTypeOutput) {
    this.resultTypeOutput = resultTypeOutput;
  }

  public ProcessParams withDoublePageSpread(Boolean doublePageSpread) {
    this.doublePageSpread = doublePageSpread;
    return this;
  }

  /**
   * This option can be set to true if the image you provide contains double page spread of the
   * passport and you want to process both pages in one go. It makes sense to use it for documents
   * that have meaningful information on both pages, like Russian domestic passport, or some others.
   * By default is set to false.
   *
   * @return doublePageSpread
   */
  @javax.annotation.Nullable
  public Boolean getDoublePageSpread() {
    return doublePageSpread;
  }

  public void setDoublePageSpread(Boolean doublePageSpread) {
    this.doublePageSpread = doublePageSpread;
  }

  public ProcessParams withFieldTypesFilter(List<Integer> fieldTypesFilter) {
    this.fieldTypesFilter = fieldTypesFilter;
    return this;
  }

  public ProcessParams addFieldTypesFilterItem(Integer fieldTypesFilterItem) {
    if (this.fieldTypesFilter == null) {
      this.fieldTypesFilter = new ArrayList<Integer>();
    }
    this.fieldTypesFilter.add(fieldTypesFilterItem);
    return this;
  }

  /**
   * List of text field types to extract. If empty, all text fields from template will be extracted.
   * Narrowing the list can shorten processing time. By default is empty.
   *
   * @return fieldTypesFilter
   */
  @javax.annotation.Nullable
  public List<Integer> getFieldTypesFilter() {
    return fieldTypesFilter;
  }

  public void setFieldTypesFilter(List<Integer> fieldTypesFilter) {
    this.fieldTypesFilter = fieldTypesFilter;
  }

  public ProcessParams withDateFormat(String dateFormat) {
    this.dateFormat = dateFormat;
    return this;
  }

  /**
   * This option allows you to set dates format so that solution will return dates in this format.
   * For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL
   * 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it
   * is set to system locale default (where the service is running).
   *
   * @return dateFormat
   */
  @javax.annotation.Nullable
  public String getDateFormat() {
    return dateFormat;
  }

  public void setDateFormat(String dateFormat) {
    this.dateFormat = dateFormat;
  }

  public ProcessParams withImageDpiOutMax(Integer imageDpiOutMax) {
    this.imageDpiOutMax = imageDpiOutMax;
    return this;
  }

  /**
   * This option controls maximum resolution in dpi of output images. Resolution will remain
   * original in case 0 is supplied. By default is set to return images in response with resolution
   * not greater than 300 dpi.
   *
   * @return imageDpiOutMax
   */
  @javax.annotation.Nullable
  public Integer getImageDpiOutMax() {
    return imageDpiOutMax;
  }

  public void setImageDpiOutMax(Integer imageDpiOutMax) {
    this.imageDpiOutMax = imageDpiOutMax;
  }

  public ProcessParams withAlreadyCropped(Boolean alreadyCropped) {
    this.alreadyCropped = alreadyCropped;
    return this;
  }

  /**
   * This option can be set to true if you know for sure that the image you provide contains already
   * cropped document by its edges. This was designed to process on the server side images captured
   * and cropped on mobile. By default is set to false.
   *
   * @return alreadyCropped
   */
  @javax.annotation.Nullable
  public Boolean getAlreadyCropped() {
    return alreadyCropped;
  }

  public void setAlreadyCropped(Boolean alreadyCropped) {
    this.alreadyCropped = alreadyCropped;
  }

  public ProcessParams withCustomParams(Map<String, Object> customParams) {
    this.customParams = customParams;
    return this;
  }

  public ProcessParams putCustomParamsItem(String key, Object customParamsItem) {
    if (this.customParams == null) {
      this.customParams = new HashMap<String, Object>();
    }
    this.customParams.put(key, customParamsItem);
    return this;
  }

  /**
   * This option allows to pass custom processing parameters that can be implemented in future
   * without changing API.
   *
   * @return customParams
   */
  @javax.annotation.Nullable
  public Map<String, Object> getCustomParams() {
    return customParams;
  }

  public void setCustomParams(Map<String, Object> customParams) {
    this.customParams = customParams;
  }

  public ProcessParams withLog(Boolean log) {
    this.log = log;
    return this;
  }

  /**
   * This option can be set to true if you need to get base64 string of transaction processing log.
   *
   * @return log
   */
  @javax.annotation.Nullable
  public Boolean getLog() {
    return log;
  }

  public void setLog(Boolean log) {
    this.log = log;
  }

  public ProcessParams withForceDocID(Integer forceDocID) {
    this.forceDocID = forceDocID;
    return this;
  }

  /**
   * Force use of specific template ID and skip document type identification step.
   *
   * @return forceDocID
   */
  @javax.annotation.Nullable
  public Integer getForceDocID() {
    return forceDocID;
  }

  public void setForceDocID(Integer forceDocID) {
    this.forceDocID = forceDocID;
  }

  public ProcessParams withMatchTextFieldMask(Boolean matchTextFieldMask) {
    this.matchTextFieldMask = matchTextFieldMask;
    return this;
  }

  /**
   * When disabled, text field OCR will be done as is and then the recognized value will be matched
   * to the field mask for validity. If enabled, we are trying to read a field value with maximum
   * efforts to match the mask and provide a correctly formatted value, making assumptions based on
   * the provided field mask in the template.
   *
   * @return matchTextFieldMask
   */
  @javax.annotation.Nullable
  public Boolean getMatchTextFieldMask() {
    return matchTextFieldMask;
  }

  public void setMatchTextFieldMask(Boolean matchTextFieldMask) {
    this.matchTextFieldMask = matchTextFieldMask;
  }

  public ProcessParams withFastDocDetect(Boolean fastDocDetect) {
    this.fastDocDetect = fastDocDetect;
    return this;
  }

  /**
   * When enabled, shorten the list of candidates to process during document detection in a single
   * image process mode. Reduces processing time for specific backgrounds.
   *
   * @return fastDocDetect
   */
  @javax.annotation.Nullable
  public Boolean getFastDocDetect() {
    return fastDocDetect;
  }

  public void setFastDocDetect(Boolean fastDocDetect) {
    this.fastDocDetect = fastDocDetect;
  }

  public ProcessParams withUpdateOCRValidityByGlare(Boolean updateOCRValidityByGlare) {
    this.updateOCRValidityByGlare = updateOCRValidityByGlare;
    return this;
  }

  /**
   * When enabled, fail OCR field validity, if there is a glare over the text field on the image.
   *
   * @return updateOCRValidityByGlare
   */
  @javax.annotation.Nullable
  public Boolean getUpdateOCRValidityByGlare() {
    return updateOCRValidityByGlare;
  }

  public void setUpdateOCRValidityByGlare(Boolean updateOCRValidityByGlare) {
    this.updateOCRValidityByGlare = updateOCRValidityByGlare;
  }

  public ProcessParams withGenerateDoublePageSpreadImage(Boolean generateDoublePageSpreadImage) {
    this.generateDoublePageSpreadImage = generateDoublePageSpreadImage;
    return this;
  }

  /**
   * When enabled together with \&quot;doublePageSpread\&quot; and there is a passport with two
   * pages spread in the image, pages will be cropped, straightened and aligned together, as if the
   * document was captured on a flatbed scanner.
   *
   * @return generateDoublePageSpreadImage
   */
  @javax.annotation.Nullable
  public Boolean getGenerateDoublePageSpreadImage() {
    return generateDoublePageSpreadImage;
  }

  public void setGenerateDoublePageSpreadImage(Boolean generateDoublePageSpreadImage) {
    this.generateDoublePageSpreadImage = generateDoublePageSpreadImage;
  }

  public ProcessParams withCheckRequiredTextFields(Boolean checkRequiredTextFields) {
    this.checkRequiredTextFields = checkRequiredTextFields;
    return this;
  }

  /**
   * When enabled, each field in template will be checked for value presence and if the field is
   * marked as required, but has no value, it will have \&quot;error\&quot; in validity status.
   *
   * @return checkRequiredTextFields
   */
  @javax.annotation.Nullable
  public Boolean getCheckRequiredTextFields() {
    return checkRequiredTextFields;
  }

  public void setCheckRequiredTextFields(Boolean checkRequiredTextFields) {
    this.checkRequiredTextFields = checkRequiredTextFields;
  }

  public ProcessParams withImageQA(ImageQA imageQA) {
    this.imageQA = imageQA;
    return this;
  }

  /**
   * Get imageQA
   *
   * @return imageQA
   */
  @javax.annotation.Nullable
  public ImageQA getImageQA() {
    return imageQA;
  }

  public void setImageQA(ImageQA imageQA) {
    this.imageQA = imageQA;
  }

  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProcessParams processParams = (ProcessParams) o;
    return Objects.equals(this.scenario, processParams.scenario)
        && Objects.equals(this.resultTypeOutput, processParams.resultTypeOutput)
        && Objects.equals(this.doublePageSpread, processParams.doublePageSpread)
        && Objects.equals(this.fieldTypesFilter, processParams.fieldTypesFilter)
        && Objects.equals(this.dateFormat, processParams.dateFormat)
        && Objects.equals(this.imageDpiOutMax, processParams.imageDpiOutMax)
        && Objects.equals(this.alreadyCropped, processParams.alreadyCropped)
        && Objects.equals(this.customParams, processParams.customParams)
        && Objects.equals(this.log, processParams.log)
        && Objects.equals(this.forceDocID, processParams.forceDocID)
        && Objects.equals(this.matchTextFieldMask, processParams.matchTextFieldMask)
        && Objects.equals(this.fastDocDetect, processParams.fastDocDetect)
        && Objects.equals(this.updateOCRValidityByGlare, processParams.updateOCRValidityByGlare)
        && Objects.equals(
            this.generateDoublePageSpreadImage, processParams.generateDoublePageSpreadImage)
        && Objects.equals(this.checkRequiredTextFields, processParams.checkRequiredTextFields)
        && Objects.equals(this.imageQA, processParams.imageQA);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        scenario,
        resultTypeOutput,
        doublePageSpread,
        fieldTypesFilter,
        dateFormat,
        imageDpiOutMax,
        alreadyCropped,
        customParams,
        log,
        forceDocID,
        matchTextFieldMask,
        fastDocDetect,
        updateOCRValidityByGlare,
        generateDoublePageSpreadImage,
        checkRequiredTextFields,
        imageQA);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProcessParams {\n");
    sb.append("    scenario: ").append(toIndentedString(scenario)).append("\n");
    sb.append("    resultTypeOutput: ").append(toIndentedString(resultTypeOutput)).append("\n");
    sb.append("    doublePageSpread: ").append(toIndentedString(doublePageSpread)).append("\n");
    sb.append("    fieldTypesFilter: ").append(toIndentedString(fieldTypesFilter)).append("\n");
    sb.append("    dateFormat: ").append(toIndentedString(dateFormat)).append("\n");
    sb.append("    imageDpiOutMax: ").append(toIndentedString(imageDpiOutMax)).append("\n");
    sb.append("    alreadyCropped: ").append(toIndentedString(alreadyCropped)).append("\n");
    sb.append("    customParams: ").append(toIndentedString(customParams)).append("\n");
    sb.append("    log: ").append(toIndentedString(log)).append("\n");
    sb.append("    forceDocID: ").append(toIndentedString(forceDocID)).append("\n");
    sb.append("    matchTextFieldMask: ").append(toIndentedString(matchTextFieldMask)).append("\n");
    sb.append("    fastDocDetect: ").append(toIndentedString(fastDocDetect)).append("\n");
    sb.append("    updateOCRValidityByGlare: ")
        .append(toIndentedString(updateOCRValidityByGlare))
        .append("\n");
    sb.append("    generateDoublePageSpreadImage: ")
        .append(toIndentedString(generateDoublePageSpreadImage))
        .append("\n");
    sb.append("    checkRequiredTextFields: ")
        .append(toIndentedString(checkRequiredTextFields))
        .append("\n");
    sb.append("    imageQA: ").append(toIndentedString(imageQA)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
