/*
 * Regula Document Reader Web API
 * Regula Document Reader Web API
 *
 * The version of the OpenAPI document: 5.2.0
 *
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */

package com.regula.documentreader.webclient.model;

import com.google.gson.annotations.SerializedName;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Objects;

/** ProcessParams */
public class ProcessParams {
  public static final String SERIALIZED_NAME_SCENARIO = "scenario";

  @SerializedName(SERIALIZED_NAME_SCENARIO)
  private String scenario;

  public static final String SERIALIZED_NAME_RESULT_TYPE_OUTPUT = "resultTypeOutput";

  @SerializedName(SERIALIZED_NAME_RESULT_TYPE_OUTPUT)
  private List<Integer> resultTypeOutput = null;

  public static final String SERIALIZED_NAME_DOUBLE_PAGE_SPREAD = "doublePageSpread";

  @SerializedName(SERIALIZED_NAME_DOUBLE_PAGE_SPREAD)
  private Boolean doublePageSpread;

  public static final String SERIALIZED_NAME_FIELD_TYPES_FILTER = "fieldTypesFilter";

  @SerializedName(SERIALIZED_NAME_FIELD_TYPES_FILTER)
  private List<Integer> fieldTypesFilter = null;

  public static final String SERIALIZED_NAME_DATE_FORMAT = "dateFormat";

  @SerializedName(SERIALIZED_NAME_DATE_FORMAT)
  private String dateFormat;

  public static final String SERIALIZED_NAME_IMAGE_DPI_OUT_MAX = "imageDpiOutMax";

  @SerializedName(SERIALIZED_NAME_IMAGE_DPI_OUT_MAX)
  private Integer imageDpiOutMax;

  public static final String SERIALIZED_NAME_ALREADY_CROPPED = "alreadyCropped";

  @SerializedName(SERIALIZED_NAME_ALREADY_CROPPED)
  private Boolean alreadyCropped;

  public static final String SERIALIZED_NAME_CUSTOM_PARAMS = "customParams";

  @SerializedName(SERIALIZED_NAME_CUSTOM_PARAMS)
  private Map<String, Object> customParams = null;

  public static final String SERIALIZED_NAME_LOG = "log";

  @SerializedName(SERIALIZED_NAME_LOG)
  private Boolean log;

  public static final String SERIALIZED_NAME_FORCE_DOC_I_D = "forceDocID";

  @SerializedName(SERIALIZED_NAME_FORCE_DOC_I_D)
  private Integer forceDocID;

  public ProcessParams withScenario(String scenario) {
    this.scenario = scenario;
    return this;
  }

  /**
   * Get scenario
   *
   * @return scenario
   */
  public String getScenario() {
    return scenario;
  }

  public void setScenario(String scenario) {
    this.scenario = scenario;
  }

  public ProcessParams withResultTypeOutput(List<Integer> resultTypeOutput) {
    this.resultTypeOutput = resultTypeOutput;
    return this;
  }

  public ProcessParams addResultTypeOutputItem(Integer resultTypeOutputItem) {
    if (this.resultTypeOutput == null) {
      this.resultTypeOutput = new ArrayList<Integer>();
    }
    this.resultTypeOutput.add(resultTypeOutputItem);
    return this;
  }

  /**
   * Types of results to return in response. See &#39;Result&#39; enum for available options
   *
   * @return resultTypeOutput
   */
  @javax.annotation.Nullable
  public List<Integer> getResultTypeOutput() {
    return resultTypeOutput;
  }

  public void setResultTypeOutput(List<Integer> resultTypeOutput) {
    this.resultTypeOutput = resultTypeOutput;
  }

  public ProcessParams withDoublePageSpread(Boolean doublePageSpread) {
    this.doublePageSpread = doublePageSpread;
    return this;
  }

  /**
   * This option can be set to true if the image you provide contains double page spread of the
   * passport and you want to process both pages in one go. It makes sense to use it for documents
   * that have meaningful information on both pages, like Russian domestic passport, or some others.
   * By default is set to false.
   *
   * @return doublePageSpread
   */
  @javax.annotation.Nullable
  public Boolean getDoublePageSpread() {
    return doublePageSpread;
  }

  public void setDoublePageSpread(Boolean doublePageSpread) {
    this.doublePageSpread = doublePageSpread;
  }

  public ProcessParams withFieldTypesFilter(List<Integer> fieldTypesFilter) {
    this.fieldTypesFilter = fieldTypesFilter;
    return this;
  }

  public ProcessParams addFieldTypesFilterItem(Integer fieldTypesFilterItem) {
    if (this.fieldTypesFilter == null) {
      this.fieldTypesFilter = new ArrayList<Integer>();
    }
    this.fieldTypesFilter.add(fieldTypesFilterItem);
    return this;
  }

  /**
   * List of text field types to extract. If empty, all text fields from template will be extracted.
   * Narrowing the list can shorten processing time. By default is empty.
   *
   * @return fieldTypesFilter
   */
  @javax.annotation.Nullable
  public List<Integer> getFieldTypesFilter() {
    return fieldTypesFilter;
  }

  public void setFieldTypesFilter(List<Integer> fieldTypesFilter) {
    this.fieldTypesFilter = fieldTypesFilter;
  }

  public ProcessParams withDateFormat(String dateFormat) {
    this.dateFormat = dateFormat;
    return this;
  }

  /**
   * This option allows you to set dates format so that solution will return dates in this format.
   * For example, if you supply &#39;MM/dd/yyyy&#39;, and document have printed date &#39;09 JUL
   * 2020&#39; for the date os issue, you will get &#39;07/09/2020&#39; as a result. By default it
   * is set to system locale default (where the service is running).
   *
   * @return dateFormat
   */
  @javax.annotation.Nullable
  public String getDateFormat() {
    return dateFormat;
  }

  public void setDateFormat(String dateFormat) {
    this.dateFormat = dateFormat;
  }

  public ProcessParams withImageDpiOutMax(Integer imageDpiOutMax) {
    this.imageDpiOutMax = imageDpiOutMax;
    return this;
  }

  /**
   * This option controls maximum resolution in dpi of output images. Resolution will remain
   * original in case 0 is supplied. By default is set to return images in response with resolution
   * not greater than 300 dpi.
   *
   * @return imageDpiOutMax
   */
  @javax.annotation.Nullable
  public Integer getImageDpiOutMax() {
    return imageDpiOutMax;
  }

  public void setImageDpiOutMax(Integer imageDpiOutMax) {
    this.imageDpiOutMax = imageDpiOutMax;
  }

  public ProcessParams withAlreadyCropped(Boolean alreadyCropped) {
    this.alreadyCropped = alreadyCropped;
    return this;
  }

  /**
   * This option can be set to true if you know for sure that the image you provide contains already
   * cropped document by its edges. This was designed to process on the server side images captured
   * and cropped on mobile. By default is set to false.
   *
   * @return alreadyCropped
   */
  @javax.annotation.Nullable
  public Boolean getAlreadyCropped() {
    return alreadyCropped;
  }

  public void setAlreadyCropped(Boolean alreadyCropped) {
    this.alreadyCropped = alreadyCropped;
  }

  public ProcessParams withCustomParams(Map<String, Object> customParams) {
    this.customParams = customParams;
    return this;
  }

  public ProcessParams putCustomParamsItem(String key, Object customParamsItem) {
    if (this.customParams == null) {
      this.customParams = new HashMap<String, Object>();
    }
    this.customParams.put(key, customParamsItem);
    return this;
  }

  /**
   * This option allows to pass custom processing parameters that can be implemented in future
   * without changing API.
   *
   * @return customParams
   */
  @javax.annotation.Nullable
  public Map<String, Object> getCustomParams() {
    return customParams;
  }

  public void setCustomParams(Map<String, Object> customParams) {
    this.customParams = customParams;
  }

  public ProcessParams withLog(Boolean log) {
    this.log = log;
    return this;
  }

  /**
   * This option can be set to true if you need to get base64 string of transaction processing log.
   *
   * @return log
   */
  @javax.annotation.Nullable
  public Boolean getLog() {
    return log;
  }

  public void setLog(Boolean log) {
    this.log = log;
  }

  public ProcessParams withForceDocID(Integer forceDocID) {
    this.forceDocID = forceDocID;
    return this;
  }

  /**
   * Force use of specific template ID and skip document type identification step.
   *
   * @return forceDocID
   */
  @javax.annotation.Nullable
  public Integer getForceDocID() {
    return forceDocID;
  }

  public void setForceDocID(Integer forceDocID) {
    this.forceDocID = forceDocID;
  }

  @Override
  public boolean equals(java.lang.Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    ProcessParams processParams = (ProcessParams) o;
    return Objects.equals(this.scenario, processParams.scenario)
        && Objects.equals(this.resultTypeOutput, processParams.resultTypeOutput)
        && Objects.equals(this.doublePageSpread, processParams.doublePageSpread)
        && Objects.equals(this.fieldTypesFilter, processParams.fieldTypesFilter)
        && Objects.equals(this.dateFormat, processParams.dateFormat)
        && Objects.equals(this.imageDpiOutMax, processParams.imageDpiOutMax)
        && Objects.equals(this.alreadyCropped, processParams.alreadyCropped)
        && Objects.equals(this.customParams, processParams.customParams)
        && Objects.equals(this.log, processParams.log)
        && Objects.equals(this.forceDocID, processParams.forceDocID);
  }

  @Override
  public int hashCode() {
    return Objects.hash(
        scenario,
        resultTypeOutput,
        doublePageSpread,
        fieldTypesFilter,
        dateFormat,
        imageDpiOutMax,
        alreadyCropped,
        customParams,
        log,
        forceDocID);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class ProcessParams {\n");
    sb.append("    scenario: ").append(toIndentedString(scenario)).append("\n");
    sb.append("    resultTypeOutput: ").append(toIndentedString(resultTypeOutput)).append("\n");
    sb.append("    doublePageSpread: ").append(toIndentedString(doublePageSpread)).append("\n");
    sb.append("    fieldTypesFilter: ").append(toIndentedString(fieldTypesFilter)).append("\n");
    sb.append("    dateFormat: ").append(toIndentedString(dateFormat)).append("\n");
    sb.append("    imageDpiOutMax: ").append(toIndentedString(imageDpiOutMax)).append("\n");
    sb.append("    alreadyCropped: ").append(toIndentedString(alreadyCropped)).append("\n");
    sb.append("    customParams: ").append(toIndentedString(customParams)).append("\n");
    sb.append("    log: ").append(toIndentedString(log)).append("\n");
    sb.append("    forceDocID: ").append(toIndentedString(forceDocID)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces (except the first line).
   */
  private String toIndentedString(java.lang.Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }
}
